#!/bin/sh

source script-x
set -u
progname="$(basename $0)"
source eexec

# Streamline access to p4review.pl

# Submission example
#perl ${P4_ROOT}/sw/main/apps/p4review/p4review.pl -save \
#    -server -uploadcmd 'curl -u svcsw:Gforcetop#1 --upload-file' \
#    $CHANGELIST

# Review example, wget:
#perl ${P4_ROOT}/sw/main/apps/p4review/p4review.pl \
#    -downloadcmd "wget --http-user=svcsw --http-passwd=Gforcetop#1" \
#    -diff p4merge -autoreview $FILENAME

# Review example, curl:
#perl ~/code/sw/main/apps/p4review/p4review.pl \
#    -downloadcmd "curl -u svcsw:Gforcetop#1 http://nvp4review/p4review/$FILE -o $FILE" \
#    [-diff p4merge] [-autoreview] $FILE



: ${P4_SW_ROOT:=$HOME/sw}
: ${DEFAULT_p4review_repository:="http://nvp4review/p4review"}
: ${password='Gforcetop#1'}
: ${p4r_opts=}
force_fetch_p=
force_no_fetch_p=
just_fetch_p=
fetch_to_file=
guess_location_p=t              # Guess from file name/syntax. Noto Implemento.
upload_p=                       # Save to server [why don't they call this upload?]
save_p=                         # Save.
save_opt=                       # Complete option.
creat_p=                        # Make a new .p4r
review_p=t                      # By default, we'll be reviewing.
verbatim_p=
: ${zipdir_opt=}                # Will look like p4 option: -zipdir <zd>

# Usage variable usage:
Usage_args_info=" .p4r-files..."
Usage_synopsis="p4review the files.
"
Usage_details="${EExec_parse_usage}
--diff <diff-prog>) Set diff program.
--server <server>) default server holding the review files.
--p4r <p4review-program>) Use this program to do the reviewing.
--p4r-opt <p4review-opt>) Add p4review-opt to the list of extra options.
--no-fetch|--file|--local) Use the file names directly and don't delete.
--fetch|--remote) Force a remote fetch.
--just-fetch|--fetch-only) Fetch the .p4r and do nothing else.
--fetch-to <file>) For just-fetch, just fetch to here.
--save) Save a p4r.
--save-to <server>) Save to <server>
--upload) Create and upload to current server.
--upload-to <server>) Create and upload to <server>.
--no-review) Don't review the arguments.
--review) Review [some options clear this].
--verbatim) Don't convert xxxx to cl-xxxx.p4r
--zipdir <zd>) Save newly created p4r files here.
--creat) Create a local .p4r file.
"
# Example of arg parsing.
long_options=("diff:" "server:" "p4r:" "p4r-opt:" "no-fetch" "file" "local"
"fetch" "just-fetch" "fetch-only" "remote" "password:" "passwd:" "pass:" "pwd:"
"fetch-to:" "verbatim" "save" "save-to:" "upload" "up" "upload-to:" "up-to:"
"no-review")
option_str="${EExec_parse_option_str}d:s:r:o:lfjp:t:cN"  # <:options:>
source dp-getopt+.sh
for i in "$@"
do
  # do. e.g.  $OPTION_ARG=$2; shift;; to process options with arguments.
  case $1 in
      # eexec support
      -n) EXEC=echo; EExecDashN;; # Don't actually execute stuff
      -v) VERBOSE="echo $progname: "; EExecVerbose;;
      -q) VERBOSE=":"; EExecQuiet;;

      # Program options.
      -d|--diff) shift; diff_program="$1";;
      -s|--server) shift; p4review_repository="$1";;
      -r|--p4r) shift; p4review_program="$1";;
      -o|--p4r-opt) shift; p4r_opts="$p4r_opts $1";;
      -l|--no-fetch|--file|--local) p4review_repository=;
                                    fetch_function=fetch_no_fetch
                                    fetch_cleanup=cleanup_no_fetch
                                    force_no_fetch_p=t
                                    guess_location_p=
                                    ;;
       # This will result in getting the default repository.
      -f|--fetch|--remote) p4review_repository=;
                           fetch_function=fetch_wget
                           fetch_cleanup=cleanup_wget
                           force_fetch_p=t
                           guess_location_p=
                           ;;
      -j|--just-fetch|--fetch-only) 
                        fetch_function=just_fetch_wget
                        fetch_cleanup=cleanup_nop
                        just_fetch_p=t
                        ;;
      -t|--fetch-to) fetch_function=just_fetch_wget
                     fetch_cleanup=cleanup_nop
                     shift; fetch_to_file="${1}"
                     ;;
      -p|--password|--passwd|--pass|--pwd)
                        shift
                        password="${1}"
                        ;;
      -N|--no-review) review_p=;;
      --review) review_p=t;;
      --verbatim) verbatim_p=t;;
      -c|--creat) creat_p=t; review_p=;;
      --save) save_p=t; review_p=;;
      --save-to) shift; p4review_repository="${1}"; save_p=t; review_p=;;
      --upload|--up) upload_p=t; review_p=;;
      --upload-to|--up-to) shift; p4review_repository="${1}"; upload_p=t; 
                           review_p=;;
      # Help!
      --help) Usage; exit 0;;
      --) shift ; break ;;
      *) echo 1>&2 "Unsupported option>$1<"
         exit 1;;
    esac
    shift
done
# The following is needed only when args are required.
[ "$*" = "" ] && Usage "At least one review file is needed."

: ${diff_program:=${P4DIFF-xxdiff}}
# p4review_repository must be NULL, not just "", for this to work.
: ${p4review_repository=$DEFAULT_p4review_repository}
: ${p4review_program:=${P4_SW_ROOT}/sw/main/apps/p4review/p4review.pl}
: ${fetch_function:=fetch_wget}
: ${fetch_cleanup:=cleanup_wget}

[ -n "${save_p}" ] && {
    save_opt="-save"
}

cleanup_tmp_files()
{
    local file_name="${1}"; shift
    [ -n "$file_name" ] && EExec rm -f "$file_name"
}

sig_handler()
{
   echo 1>&2  "rc>$?<"
   {
        local sig="${1}"; shift
        echo  "sig_handler: sig: ${sig}, args>$@<"
        cleanup_tmp_files "$@"
        echo "Exiting..."
    } 1>&2
   exit 1
}

set_traps()
{
    local handler="${1}"; shift
    local handler_args="${1}"; shift
    for sig in "$@"
    do
      trap "$handler $sig ${handler_args}" $sig
    done
}

cleanup_nop()
{
    EExec -y true
}
fetch_no_fetch()
{
    EExec -y echo "${1}"
}

cleanup_no_fetch()
{
    cleanup_nop
}

cleanup_wget()
{
    cleanup_tmp_files "${1}"
}

# > p4 changes -u dpanariti
#Change 17156093 on 2013/01/18 by dpanariti@dpanariti-t124_1 *pending* 'Add prints to EngMsenc::~EngMse'
verify_my_cl()
{
    local cl="${1}"; shift
    EExec_verbose_msg "verify_my_cl>$cl<"
    p4 changes -u "${USER}" | egrep -q "Change ${cl} on" >/dev/null 2>&1
}

do_fetch_wget()
{
    # $1 -- File to fetch.
    # $2 -- Server to fetch from.
    # $3 -- Destination file.
    
    local fetch_file="${1}"; shift
    local server="${1}"; shift
    local dest_file="${1}"; shift
    local tmp_file

    tmp_file=$(mktemp "$HOME/tmp/dp4-review.tmp.XXXXXXX") || {
        echo "Couldn't make a temp file."
        exit 1
    } 1>&2
    EExec wget --http-user=svcsw \
      "--http-passwd=${password}" \
      -O "${dest_file}" \
     "${server}/${fetch_file}"
    echo "${dest_file}"
}

fetch_wget()
{
    # $1 -- File to fetch.
    # $2 -- Server to fetch from.
    local tmp_file
    tmp_file=$(mktemp "$HOME/tmp/dp4-review.tmp.XXXXXXX") || {
        echo "Couldn't make a temp file."
        exit 1
    } 1>&2
    set_traps "sig_handler" "$tmp_file" ERR 1 2 3 4 5 6 7 8 10 11 12 13 15 # EXIT
    do_fetch_wget "${1}" "${2}" "${tmp_file}"
}

just_fetch_wget()
{
    # $1 -- File to fetch.
    # $2 -- Server to fetch from.
    local fetch_to=${fetch_to_file:=$1}
    do_fetch_wget "${1}" "${2}" "${fetch_to}"
}

dp4r_create()
{
    local cl="${1}"; shift
    verify_my_cl "${cl}" || {
        echo "$progname: Cannot verify changelist number ${cl}"
        exit 1
    } 1>&2
    # E.g. support: p4review.pl -zipdir . -save 17156093
    # Always create locally, and send to server as a possible additional step?
    EExec perl "$p4review_program" \
       ${zipdir_opt} \
       ${save_opt} \
       "${cl}"
}

#perl ${P4_ROOT}/sw/main/apps/p4review/p4review.pl -save \
#    -server -uploadcmd 'curl -u svcsw:Gforcetop#1 --upload-file' \
#    $CHANGELIST

dp4r_upload()
{
    local cl="${1}"; shift
    verify_my_cl "${cl}" || {
        echo "$progname: Cannot verify changelist number ${cl}"
        exit 1
    } 1>&2
    # E.g. support: p4review.pl -zipdir . -save 17156093
    # Always create locally, and send to server as a possible additional step?
    EExec perl "$p4review_program" \
       -save \
       -server \
       -uploadcmd 'curl -u svcsw:Gforcetop#1 --upload-file' \
       "${cl}"
}

dp4r_review()
{
    local f="${1}"
    case "$f" in
        *://*) set -- $(echo "$f" | sed -rn 's!(.*://.*)(/)(.*)$!\1 \3!p');
               f="${2}"
               repo="${1}"
               ;;
        *) repo="${p4review_repository}";;
    esac
  
    f=$($fetch_function "${f}" "${repo}")
    if [ -z "${just_fetch_p}" ]
    then
        EExec perl "$p4review_program" \
           ${p4r_opts} \
           -diff "${diff_program}" -autoreview "${f}"
        $fetch_cleanup "${f}"
    else
        true
    fi
}

# If we do the ops in order, we can create/save/review a new p4r.
# Some combinations may not make sense.
for f in "$@"
do
  if [ -z "${just_fetch_p}" ]
  then
      if [ -n "${creat_p}" ]
      then
          
          # Should we do a run-through of that which is to submitted?
          # We create via CL, but other commands use formats w/other names.
          dp4r_create "${f}"
      fi
      if [ -n "$upload_p" ]
      then
          dp4r_upload "${f}"
      fi
  fi

  if [ -n "$review_p" ]
  then
      [ -z "${verbatim_p}" ] && {
          case "$f" in
              cl-*) ;;
              *) f="cl-${f}.p4r";;
          esac
      }
      dp4r_review "${f}"
  fi
done
