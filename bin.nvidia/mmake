#!/bin/sh

source script-x
source eexec
set -u
progname="$(basename $0)"

: ${o_xterm_ok_p=}

eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program

cat_log()
{
    cat
}

null_log()
{
    cat > /dev/null
}

tee_log()
{
    if [ -n "${log_file}" ]
    then
        tee "${log_file}"
    else
        cat_log
    fi
}

# Usage variable usage:
Usage_args_info=' `depth`/bin/make-options-and-args...'
Usage_synopsis='make using `depth`/bin/make
'
Usage_details="${EExec_parse_usage}
--log-file <file> -- Log output to <file>.
--logger <logger> -- Log with tee or cat.
--null -- Send output to /dev/null
"
# Example of arg parsing.
option_str="${EExec_parse_option_str}"
long_options=("logger:" "log-file:" "null" "override" "o-xterm-ok")
source dp-getopt+.sh
for i in "$@"
do
  # do. e.g.  shift; $OPTION_ARG=$1;; # to process options with arguments.
  case $1 in
      # eexec support
      -n) EXEC=echo; EExecDashN;; # Don't actually execute stuff
      -v) VERBOSE="echo $progname: "; EExecVerbose;;
      -q) VERBOSE=":"; EExecQuiet;;

      # Program options.
      --logger) shift; logger="$1";;
      --log-file) shift; log_file="$1";;
      --null) log_file=/dev/null;;
      --override|--o-xterm-ok) o_xterm_ok_p=y;;

      # Help!
      --help) Usage; exit 0;;
      --) shift ; break ;;
      *) echo 1>&2 "Unsupported option>$1<"
         exit 1;;
    esac
    shift
done

on-o-xterm-p && vunsetp "${o_xterm_ok_p}" && {
    echo "$progname: Should not do this on an o-xterm box."
    exit 1
} 1>&2


: ${log_file=}
: ${logger:=cat_log}

depth=$(depth)
EExec ${depth}/bin/make "$@" 2>&1 | $logger
