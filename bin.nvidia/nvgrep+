#!/bin/sh

source script-x
set -u
progname="$(basename $0)"
source eexec
if vsetp "${eexec_program-}"    # Did the caller provide a program?
then
    EEXEC_SHIFT=:
else
    eexec_program=$(EExec_parse "$@")
    EEXEC_SHIFT=shift
fi

for op in $eexec_program
do
  $op
  ${EEXEC_SHIFT}
done
EExec_verbose_msg $(echo_id eexec_program)
unset eexec_program
# Or export eexec_program to propagate eexec info to a called program.
# export eexec_program

disp_realpath()
{
    local FILE_NAME="$1"

    file_name=$(echo "${FILE_NAME}" | sed -rn 's/(.*):([0-9]+)(:[[:space:]]+.*)/\1/p')
    line_num=$(echo "${FILE_NAME}" | sed -rn 's/(.*):([0-9]+)(:[[:space:]]+.*)/\2/p')
    rest_o_line=$(echo "${FILE_NAME}" | sed -rn 's/(.*):([0-9]+)(:[[:space:]]+.*)/\3/p')
    file_name=$(realpath "${file_name}")
    echo "${file_name}:${line_num}${rest_o_line}"
}
 
: ${sandbox=}
: ${number_lines_opt=-n}
: ${realpath_p=t}
: ${tot_p=t}
: ${tot=TOT}                    # An SB_REL abbrev

while (($# > 0))
do
  case "$1" in
      --sandbox|--sb) shift; sandbox="${1}";;
      --no-tot) tot_p=;;
      --to-tot) tot_p=t;;
      --tot) shift; tot=${1}; tot_p=t;;
      --no-number-lines|--no-line-numbers|--nn) number_lines_opt=;;
      --number-lines|--line-numbers|--nl) number_lines_opt=t;;
      --relpath|--rel-path|--relative-path) realpath_p=;;
      --realpath|--rp) realpath_p=t;;
      --) shift; break;;
      *) break;;
  esac
  shift
done

true_p "${tot_p}" && {
    mecd "${tot}" || {
        echo "Cannot find TOT."
        exit 1
    } 1>&2
}

REAL_NVGREP=$(sp nvgrep | fgrep -v "$HOME" | head -n1)

if true_p "${realpath_p}"
then
    disp_fun=disp_realpath
else
    disp_fun=echo
fi

# example output line:
# clib/RAMCMdl/ramif_core.cpp:2110:      if (!ramPtr) {construct_ram();}
EExec "${REAL_NVGREP}" ${number_lines_opt} "$@" | while read
do
  "${disp_fun}" "${REPLY}"
done
  
