#!/bin/sh

source script-x
source eexec
set -u
progname="$(basename $0)"
: ${sleep_interval:=10}
: ${continue_regexp:=RUN}
: ${batch_dir:=$(newest-dir)}
: ${status_program:=./batch_status}
: ${default_status_program_args=${batch_dir}}
: ${continue_pred_program:=egrep}
: ${show_final_batch_status_p=t}
: ${final_batch_status_post_process=pp_status_and_test_dir}
: ${default_continue_pred_args:=-q ${continue_regexp}}
: ${run_p=t}


option_str="${EExec_parse_option_str}b:s:c:g:fP:"

# Usage variable usage:
Usage_args_info="" # $option_string is shown by default
Usage_synopsis="Wait for a testgen batch job to finish.
"
Usage_details="While there are a lot of options, by default this will run:
${status_program} <newest-dir> | ${continue_pred_program} ${default_continue_pred_args}
and stop sleeping and looping when ${continue_regexp} is not in the output of 
${status_program}
-c <regexp> AND -b <batch-dir> will probably be the most common options.

Options:
${EExec_parse_usage}
-b <batch-dir> -- Dir to monitor.
-s <sleep-interval> -- How long to sleep between iterations.
-c <continue-regexp> -- Continue as long as this regexp is present in 
                        <status-program>'s output.
-p <status-program> -- Program to run each iteration to determine run status.
-A <status-program-args> -- Args to <status-program>. Just <batch-dir> by default.
-e <continue-pred-program> -- What to run to process <status-program>'s output
                              to determine if we should continue looping.
-a <continue-pred-args> -- Args to <continue-pred-program>.
-f -- Do not run <status-program> after looping.
-P <post> -- Postprocess final <status-program>'s output.
"

pp_just_status()
{
    awk '{print $1}'
}

pp_status_and_test_dir()
{
    awk '{print $1 " : " $3}'
}

stop_looping()
{
    echo 1>&2 "Loop interrupted."
    run_p=;
    sleep_interval=1
}

sigtrap()
{
    {
        local signum="$1"; shift
        echo "caught signal >$signum<"
        exit $signum
    } 1>&2
}

for sig in 3 4 5 6 7 8 15
do
	trap "sigtrap $sig" $sig
done

trap stop_looping 2

source dp-getopt+.sh
for i in "$@"
do
  # do. e.g.  $OPTION_ARG=$2; shift;; to process options with arguments.
  case $1 in
      # eexec support
      -n) EXEC=echo; EExecDashN;; # Don't actually execute stuff
      -v) VERBOSE="echo $progname: "; EExecVerbose;;
      -q) VERBOSE=":"; EExecQuiet;;

      # Program options.
      -b) shift; batch_dir=$1;;
      -s) shift; sleep_interval=$1;;
      -c) shift; continue_regexp=$1;;
      -P) shift; final_batch_status_post_process=$1;;
      -f) show_final_batch_status_p=;;

      # Help!
      --help) Usage; exit 0;;
      --) shift ; break ;;
      *) echo 1>&2 "Unsupported option>$1<"
         exit 1;;
    esac
    shift
done

: ${status_program_args=${default_status_program_args}}
: ${continue_pred_args:=${default_continue_pred_args}}

EExec_verbose_msg "batch_dir>${batch_dir}<"
EExec_verbose_msg "sleep_interval>${sleep_interval}<"
EExec_verbose_msg "continue_regexp>${continue_regexp}<"
EExec_verbose_msg "status_program_args>${status_program_args}<"
EExec_verbose_msg "continue_pred_args>${continue_pred_args}<"

while [ -n "$run_p" ]
do 
  EExec "${status_program}" ${status_program_args} \
    | EExec "${continue_pred_program}" ${continue_pred_args} || {
      echo "Failure required to exit loop."
      break
  } 1>&2
  echo -n "sleep for ${sleep_interval}..."
  sleep "${sleep_interval}"
  echo 'Awaken.'
done

[ -n "${show_final_batch_status_p}" ] && {
    echo "Final status:"
    EExec "${status_program}" ${status_program_args} \
       | EExec ${final_batch_status_post_process}
}

exit 0
