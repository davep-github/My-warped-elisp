#!/bin/sh

source script-x
set -u
progname="$(basename $0)"
source eexec
if vsetp "${eexec_program-}"    # Did the caller provide a program?
then
    EEXEC_SHIFT=:
else
    eexec_program=$(EExec_parse "$@")
    EEXEC_SHIFT=shift
fi

for op in $eexec_program
do
  $op
  ${EEXEC_SHIFT}
done
EExec_verbose_msg $(echo_id eexec_program)
unset eexec_program
# Or export eexec_program to propagate eexec info to a called program.
# export eexec_program

: ${purge_opt=}
: ${debug_opt=-debug=1}
: ${build_prog:=./build_gpu_multiengine.pl}
: ${yopp_p=t}
: ${silent_p=}
: ${auto_no_debug_p=t}
: ${allow_debug_p=t}

teeker_output()
{
    teeker --test-log "${progname}.out"
}

# Usage variable usage:
Usage_args_info=" bgme [--purge] [--no-debug]"
Usage_synopsis="Build GPU ME plugins:
"
# Using ) after the args makes copy & paste between here and the
# case statement easier.
Usage_details="${EExec_parse_usage}
--purge) Build purge target
-n|-d|--no-debug) Don't build with -debug=1
--build) Build program
-y|--no-yopp) Don't send email when done
"
# Example of arg parsing.
option_str="${EExec_parse_option_str}pnd"
long_options=(
"purge"
"no-debug" "nd"
"build"
"no-yopp"
"silent"
"auto-no-debug"
"teeker"
)

source dp-getopt+.sh
while (($# > 0))
do
  # do. e.g.  shift; $OPTION_ARG=$1;; # to process options with arguments.
  case $1 in
      # eexec support
      # Done by EExec_parse and friends.

      # Program options.
      -p|--purge) purge_opt=purge;;
      -n|-d|--no-debug|--nd) debug_opt=;;
      --build) shift; build_prog="${1}";;
      -y|--no-yopp) yopp_p=;;
      --silent) silent_p=t;;
      --no-auto-no-debug) auto_no_debug_p=;;
      --teeker) output_processor=teeker_output;;
      --cat)    output_processor=cat;;

      # Help!
      --help) Usage; exit 0;;
      --) shift ; break ;;
      *) echo 1>&2 "Unsupported option>$1<"
         exit 1;;
    esac
    shift
done

mecd testgen
EExec_verbose_msg "pwd: $(pwd)"
vsetp "${purge_opt}" && {
    EExec "${build_prog}" ${purge_opt}
}

vsetp "${debug_opt}" && ! true_p "${allow_debug_p}" && {
    tree_dot_make=$(me-expand-dest tot)/tree.make
    [ -e "${tree_dot_make}" ] || {
        echo "${tree_dot_make} does not exist as should be."
        exit 1
    } 1>&2

    egrep -q '^[[:space:]]*export[[:space:]]+(NV_)?PROJECTS?.*t132_debug' "${tree_dot_make}"  || {
        if true_p "${auto_no_debug_p}"
        then
            true_p "${silent_p}" || {
                echo
                echo "Auto clearing debug flag"
                echo
            }
        else
            read -e -p "There is no debug project specified in ${tree_dot_make}.
Clear flag and continue [Y/n]? "
            case "${REPLY}" in
                [yYtT1.]|"") ;;
                *) echo "Exiting."; exit 0;;
            esac
        fi
    }
    echo "Removing ${debug_opt} and continuing."
    debug_opt=
}


: ${output_processor:=cat}



EExec "${build_prog}" ${debug_opt} 2>&1 | EExec ${output_processor}
rc=$?

vsetp "${yopp_p}" && {
    EExec email-yopp "RC: ${rc}: GPU ME build done."
}

