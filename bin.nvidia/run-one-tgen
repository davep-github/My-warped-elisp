#!/bin/sh

source script-x
source eexec
set -u
progname="$(basename $0)"

# Usage variable usage:
Usage_args_info=" <tgen-level-test>..."
Usage_synopsis="Run tgen levels one at a time using a consistent set of vars.
See also tgen.pl and testgen.pl for additional ops.
"
Usage_details="${EExec_parse_usage}
-w -- Wait for completion rather than submitting to LSF.
-T <tgen-opt> -- Add value to an additional string of tgen options.
-C -- Clear clobber opt.
-l <level> -- Specify tgen level file.
-r <trace-root> -- Root for traces.
-c <chip> -- Chip name/type.
-t <target> -- E.g. FMODEL.
-d <???> -- Default is hwApPath=$(pwd)/../../
--wait -- Run synchronously. Implies --nomail. --mail after this will override.
--status -- Print status after a sync run.
--wait-status|--status-wait|--ws -- --wait and --status.
--nomail -- No status/results mail is sent upon completion.
--mail -- Not --nomail.
"
# Example of arg parsing.
option_str="${EExec_parse_option_str}wT:Cl:r:c:t:d:"
long_options=("wait"
"tgen-opt:"
"clobber"
"level:"
"trace-root:"
"chip:"
"target:"
"log-dir:"
"log-base:"
"status"
"status-wait"
"wait-status"
"ws"
"nomail"
"mail")

: ${default_level=$(pwd)/config/levels/tegra/regress_tegra_gpu_multiengine}
: ${user_levels=}
: ${user_tgen_opts=}
: ${mail_opt=}                  # Whatever tgen*'s default is.

source dp-getopt+.sh
for i in "$@"
do
  # do. e.g.  $OPTION_ARG=$2; shift;; to process options with arguments.
  case $1 in
      # eexec support
      -n) EXEC=echo; EExecDashN;; # Don't actually execute stuff
      -v) VERBOSE="echo $progname: "; EExecVerbose;;
      -q) VERBOSE=":"; EExecQuiet;;

      # Program options.
      # No mail if we're waiting. Can be turned on by a following --mail.
      -w|--wait) wait_opt=-wait; mail_opt="-nomail";;
      -T|--tegn-opt) shift; user_tgen_opts="$user_tgen_opts $1";;
      -C|--clobber) clobber_opt=;;
      -l|--level) shift; llist=$(echo "$1" | sed -r 's/,/ /g')
                  user_levels="${user_levels} ${llist}";;
      -r|--trace-root) shift; traceRoot_opt="$1";;
      -c|--chip) shift; chip_opt="$1";;
      -t|--target) shift; target_opt="$1";;
      -d) shift; d_opt="$1";;
      --log-dir) shift; user_log_dir="$1";;
      --log-base) shift; log_dir_base="$1";;
      --wait-status|--status-wait|--ws) wait_opt="-wait"; mail_opt='-nomail';
                                        display_status_p=t;;
      --status) display_status_p=t;;
      --nomail) mail_opt=;;
      --mail) mail_opt="-mail";;
      # Help!
      --help) Usage; exit 0;;
      --) shift ; break ;;
      *) echo 1>&2 "Unsupported option>$1<"
         exit 1;;
    esac
    shift
done
# The following is needed only when non optional args are required.
[ "$*" = "" ] && {
    Usage "Test name[s] are required."
    exit 1
}

: ${wait_opt=}
: ${tgen_opts=${user_tgen_opts}}
: ${clobber_opt=-clobber}
: ${levels:=${user_levels:-${default_level}}}
: ${traceRoot_opt=/home/scratch.traces02/arch/traces/}
: ${chip_opt=t124}
: ${target_opt=FMODEL}
: ${d_opt=hwApPath=$(pwd)/../../}
: ${user_log_dir=}
: ${log_dir_base=dp-run-tgens.d}
: ${log_dir=${user_log_dir}}
: ${display_status_p=}

# Common timestamp
timestamp=$(dp-std-timestamp)

[ -z "$levels}" ] && {
    Usage "At least one level is needed."
    exit 1
}

[ -z "$user_log_dir" ] && {

    [ -z "$log_dir_base" ] && {
        log_dir_base="$log_root/${timestamp}"
    }

    log_dir_base=$(normpath "$log_dir_base")
    log_dir="$log_dir_base"
}
EExec mkdir -p $(dirname "$log_dir_base")

[ -n "$traceRoot_opt}" ] && {
        traceRoot_opt="-traceRoot $traceRoot_opt"
}
[ -n "$chip_opt}" ] && {
        chip_opt="-chip $chip_opt"
}
[ -n "$target_opt}" ] && {
        target_opt="-target $target_opt"
}
[ -n "$d_opt}" ] && {
        d_opt="-d $d_opt"
}

log_prefix="$log_dir"

[ -n "$display_status_p" -a -z "$wait_opt" ] && {
    echo "WARNING: display status and wait do not play well together."
} 1>&2

echo_id levels
for level in $levels
do
  level_opt="-level $level"
  echo "\$@>$@<"
  echo_id level
  for test_name in "$@"
  do
    echo_id test_name
    if [ -n "$user_log_dir" ]
        then
        out_dir="$user_log_dir"
    else
        out_dir="${log_prefix}/${test_name}/${timestamp}${wait_opt}.out"
        out_dir=$(normpath "$out_dir")
    fi
    
    EExec mkdir -p $(dirname "$out_dir")
    echo "$out_dir" >| last_out_dir
    
    if [ "${test_name}" = 'all' ]
    then
        only_opt=
    else
        only_opt="-only ${test_name}"
    fi
    cmd="./tgen.pl ${target_opt} ${chip_opt} ${level_opt} ${d_opt} ${traceRoot_opt} ${only_opt} -outDir $out_dir ${wait_opt} ${mail_opt} ${clobber_opt} ${tgen_opts}"
    echo "$cmd" > "${out_dir}.command-line"
    EExec $cmd
#     EExec ./tgen.pl \
#       ${target_opt} \
#       ${chip_opt} \
#       ${level_opt} \
#       ${d_opt} \
#       ${traceRoot_opt} \
#       ${only_opt} \
#       -outDir "$out_dir" \
#       ${wait_opt} \
#       ${mail_opt} \
#       ${clobber_opt} \
#       ${tgen_opts}
    
    [ -n "$display_status_p" ] && {
        EExec ./batch_status "$out_dir"
    }
  done
done
