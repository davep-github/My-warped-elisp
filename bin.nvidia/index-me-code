#!/bin/sh

#
# Index code. ME used to mean Multiengine, but that's not the only thing done
# now.
# There are two basic entities:
# 1) database locations - db-locs
#    Places where cscope and global databases reside.
# 2) directories of interests - doi dois dsoi
#    Trees we wish to index
#
# For each db-loc, any doi under it is added to db-loc's db.
#
# The entities can be SB relative names.
#

source script-x
set -u
progname="$(basename $0)"
source eexec
if vsetp "${eexec_program-}"    # Did the caller provide a program?
then
    EEXEC_SHIFT=:
else
    eexec_program=$(EExec_parse "$@")
    EEXEC_SHIFT=shift
fi

for op in $eexec_program
do
  $op
  ${EEXEC_SHIFT}
done
#unset eexec_program
# Or export eexec_program to propagate eexec info to a called program.
export eexec_program

: ${oot_only_p=}
# These are me-expand'd
# Additional ap type dirs will need to be -a'd.
source $HOME/.rc/env.nvidia
#
# NB!!!!!!!
# This may (might, should) be set inside an rc file. E.g. env.nvidia
: ${db_locs=${DP_NV_SRC_INDEX_DB_LOCS=ap //arch //sw/dev //sw/mods //sw/tools //hw/class //hw/kepler1_gklit3 //hw/tools}}
# This may (might, should) be set inside an rc file. E.g. env.nvidia
# NB!!!!!!!
: ${db_loc_excludes=}
: ${hw_ap_p=t}
: ${me_tests_p=t}
: ${manuals_p=t}
: ${more_depot_dirs_p=t}
: ${hw_dirs_p=t}
: ${sw_dirs_p=t}
: ${fmod_dirs_p=t}
: ${chip_tools_dirs_p=t}
: ${make_script_p=t}
: ${script_name=}
: ${bg_p=}
: ${index_option_desc=Indexing}
: ${clean_opt=}
: ${just_show_db_locs_p=}
: ${just_show_doi_p=}
: ${just_show_index_dirs_p=}

run_it()
{
    local bg_p="${1}"
    shift
    local run_dir="${1}"
    shift
    local script_opts=
    local op="Indexing"

    if vsetp "${script_name}"
    then
        script_opts="--sh-cd --sh: ${script_name}"
    elif true_p "${make_script_p}"
    then
        sh_name=$(toupper "${progname}-eexec")"-${USER}.sh"
        EExec_verbose_echo_id sh_name
        script_opts="--sh-cd --sh: ${sh_name}"
        EExec_verbose_echo_id script_opts
    fi
    
    EExec_verbose_echo_id script_opts

    (
        cd "${db_loc}"
        EExec_verbose_echo_id --msg "${index_option_desc} in: " PWD
        if true_p "${bg_p}"
        then
            EExec ${script_opts} "$@" &
        else
            EExec ${script_opts} "$@"
        fi
    )
}
        
        
#WTF? nvcscope_filter()
#WTF? {
#WTF?     egrep -v '/ap(_tlit[0-9]/'
#WTF? }

no_filter()
{
    cat
}

filter_dirs()
{
    local re="$1"
    shift
    # Get one per line. I'm sure there're 10^6 better ways to do this. split/cut?
    for d in "$@"
    do
      echo "$d"
    done | egrep -v "$re"
}

OOT_DIR=$HOME/work/out-of-tree-dirs
# All must be absolute
out_of_tree_dirs=/home/scratch.traces02/mobile/traces/system/so
index_out_of_tree_locations()
{
    if vunsetp "${out_of_tree_dirs}" \
         || ! test -d ${out_of_tree_dirs} \
         || ! test -d "${OOT_DIR}"
    then
        return 0
    fi
    local oot_files_file=$(normpath "${OOT_DIR}/oot.files")
    EExec find-src-code-files ${out_of_tree_dirs} > "${oot_files_file}"
    # Places like home.scratch.traces02.mobile.traces.system.so which do
    # not reside in a checked out tree. I don't know
    # how/when/why/where/from where these come, but there they are.
    # Apparently they are ~needed to make it go~.
    (
        # gtags can really be a PITA sometimes.
        EExec cd /
        EExec gtags -f "${oot_files_file}" "${OOT_DIR}"

        EExec cd "${OOT_DIR}"
        EExec ${DP_CSCOPE_PROGRAM-cscope} -q -b -i "${oot_files_file}"
    )
}

: ${ap_dir:=}
: ${send_mail_on_completion_p:=t}
# Existence of different dirs is one thing, but different names for the same
# fooking dirs is fooking stoopid. So I can't use it. What a crock.
: ${nvcscope_p=}
# At the least, just_nvcscope_p prevents me needing to know the nvcscope
# option name to make symlinks.
: ${just_nvcscope_p=}
: ${nvcscope_files=cscope.files cscope.out cscope.out.in cscope.out.po}
: ${skip_cd_p=}
: ${follow_links_opt=}
: ${follow_links_on_command_line=t}
: ${cron_opt=}

link_or_non_existent()
{
    local file="${1}"
    shift

    ! [ -e "${file}" ] || [ -L "${file}" ]
}

# Usage variable usage:
Usage_args_info=""
Usage_synopsis="Index some useful, hard coded source dirs
Don't use the nvcscope ap index by default.
"
# Using ) after the args makes copy & paste between here and the 
# case statement easier.
Usage_details="${EExec_parse_usage}
-m|--no-nvcscope|--old-sk00l) Mundane usage, just index all dirs into sandbox
                              root just like the old days.
--nvcscope|--new-sk00l) Use nvcscope's db for ap tree. Currently problematical
                        because GTAGS can only use one db, so the non-ap GTAGS
                        needs *all*files. TODO: clean cscope_p in index-code so 
                        only global indices will be generated.
-j|--no-me-index|--no-arch-index|--no-other-index) Just set up nvcscope.
-k|--clean) Clean up indexes.
--just-show-dbs|--dbs) Just show the db locations and exit.
-oot) Index out of tree files only.
"
# Example of arg parsing.
option_str="${EExec_parse_option_str}jmhHe:a:i:k"
long_options=(
"mundane" "no-nvcscope"
"no-me-index" "no-arch-index" "just-nvcscope" "links" "just-links"
"skip-cd" "stay-put" "oot" "cron"
"exclude-db-loc:"
"add-db-loc:"
"init-db-loc:"
"bg"
"clean"
"just-show-dbs" "dbs"
"doi" "dirs-of-interest" "dois"
"ids" "just-show-index-dirs" "sids"
"make-script"
"no-script" "no-make-script"
"script-name")
source dp-getopt+.sh
for i in "$@"
do
  # do. e.g.  shift; $OPTION_ARG=$1;; # to process options with arguments.
  case $1 in
      # Program options.

      -m|--no-nvcscope|--mundane) nvcscope_p=;;
      --nvcscope|--new-sk00l) nvcscope_p=t;;
      -j|--no-me-index|--no-arch-index|--no-other-index|--links|--just-links) just_nvcscope_p=t;;
      -h) follow_links_opt=-h;;
      -H) follow_links_opt=;;
      --skip-cd|--stay-put) skip_cd_p=t;;
      --oot) oot_only_p=t; nvcscope_p=; just_nvcscope_p=;;
      --cron) cron_opt="--cron";;
      -e|--exclude-db-loc) shift; db_loc_excludes="${db_loc_excludes} ${1}";;
      -a|--add-db-loc) shift; db_locs="${db_locs} ${1}";;
      -i|--init-db-loc) shift; db_locs="${1}";;
      --bg) bg_p=t;;
      --make-script) make_script_p=t;;
      --no-script|--no-make-script) make_script_p=;;
      --script-name) shift; script_name="${1}"; make_script_p=t;;
      -k|--clean) clean_opt=-k; index_option_desc="Cleaning";;
      --just-show-dbs|--dbs) just_show_db_locs_p=t; send_mail_on_completion_p=;;
      --dirs-of-interest|--doi|--dois) just_show_doi_p=t; send_mail_on_completion_p=;;
      --ids|--sids|--just-show-index-dirs) just_show_index_dirs_p=t; send_mail_on_completion_p=;;
      # Help!
      --help) Usage; exit 0;;
      --) shift ; break ;;
      *) dp_echo2 "Unsupported option>$1<"
         exit 1;;
    esac
    shift
done

if true_p "${oot_only_p}"
then
    index_out_of_tree_locations
    dp_echo "Indexing oot only. Exiting."
    exit
fi

[ -z "$ap_dir" ] && {
    ap_dir=$(find-ap-dir) || {
        echo "Cannot find ap dir."
        echo " Cannot index any ap sub-directories."
    } 1>&2
}
EExec_verbose_echo_id ap_dir

vsetp "${ap_dir}" && {
    [ -d "${ap_dir}" ] || {
        dp_echo "ap_dir>${ap_dir}<, isn't."
        exit 1
    } 1>&2
}

vsetp "${skip_cd_p}" || EExec -y mecd sandbox
dp_echo2 "cwd: $(pwd)"

ap_path="${ap_dir}"
ap_dir=$(basename "${ap_dir}")
: ${p4_root=${1-"."}}
p4_root=$(realpath "${p4_root}")

true_p "${just_nvcscope_p}" && {
    nvcscope_p=t
}

ap_hw_p4_path="//hw/${ap_dir}"
ap_gpu_me_inf="//hw/ap/ip/inf/gpu_multiengine/1.0"

# For T124/132 work, you want
# //arch/traces/mobile/traces/gpu_multiengine/sanity_gr_disp_syncpt
# //hw/ap_tlit1/inf/mods/trace_3d/plugin/1.0/src/t3dplugin.cpp

#
# Original suggested minimal set of files to index for MultiEngine Testing..
# //hw/${ap_dir}/drv/drvapi
# //hw/${ap_dir}/drv/multiengine
# //arch/traces/mobile/traces/gpu_multiengine/
# //arch/traces/mobile/traces/nongpu_multiengine/
# //hw/${ap_dir}/inf/mods/trace_3d/plugin/
#
# /home/scratch.dpanariti_t124/t124_0/arch/traces/mobile/traces/gpu_multiengine/sanity_bsea/sanity_bsea.cpp

pre_t210_gpu_me_tests="
//arch/traces/mobile/traces/gpu_multiengine/"
pre_t210_non_gpu_me_tests="
//arch/traces/mobile/traces/nongpu_multiengine/"
pre_t210_me_tests="
${pre_t210_gpu_me_tests}
${pre_t210_non_gpu_me_tests}"

t210_gpu_me_tests="
${ap_gpu_me_inf}/clib/gpu_multiengine"
t210_non_gpu_me_tests=""            # ??? Where be them?
t210_me_tests="
${t210_gpu_me_tests}
${t210_non_gpu_me_tests}"

chip=$(guess-chip)
EExec_verbose_msg "guessed $(echo_id chip)"
case "${chip}" in
    t210) me_tests="${t210_me_tests}";;
    t124|t132) me_tests="${pre_t210_gpu_tests-}";;
    *) echo 1>&2 "Unknown chip>${chip}<, bagging me_tests."
       me_tests_p=;;
esac

on_exit()
{
    local signum="${1-}"; shift

    true_p "${send_mail_on_completion_p-}" && {
        EExecDashN_p || {
            EExec email-yopp "on_exit: rc: $rc; ${cron_opt}"
        }
    }
}

on_error()
{
    local rc="${1-}"; shift
    true_p "${send_mail_on_completion_p-}" && {
        EExec email-yopp "on_error: rc: $rc; ${cron_opt}"
    }
}

trap "on_exit 0" 0
trap "on_error \$?" 0

dump_list()
{
    local title="${1}"
    shift
    echo "${title}:"
    for e in "${@}"
    do
      vsetp "${e}" && echo "  >${e}<"
    done
}
      
#
# New layout:
# //hw/ap/ip/inf/gpu_multiengine/1.0/clib/gpu_multiengine
#
### Files out of source tree when using /home/scratch.traces02/mobile/traces/system/so/
### Tried to do it at root, but it makes things relative to root, e.g. /home/x --> home/x

# The depot_dirs_of_interest are directories we wish to have indexed.
# They will be indexed into an index dir that matches the leading part of the
# index's dir name.
# e.g. given a db dir of /a/b/c
# dirs /a/b/c/d/e/q/... and /a/b/c/z/...
# will be indexed into /a/b/c's index.
# /a/b/d won't.
depot_dirs_of_interest=""

if true_p "${hw_ap_p}"
then
    depot_dirs_of_interest="
${depot_dirs_of_interest}
${ap_hw_p4_path}/drv/drvapi/
${ap_hw_p4_path}/drv/multiengine/
${ap_hw_p4_path}/inf/mods/trace_3d/plugin/"
fi

if true_p "${me_tests_p}"
then
    depot_dirs_of_interest=="${depot_dirs_of_interest} ${me_tests}"
fi

if true_p "${manuals_p}"
then
    depot_dirs_of_interest="
${depot_dirs_of_interest} 
//hw/kepler1_gklit3/manuals/"
fi

# too big: //hw/${ap_dir}/include/
# Taken care of with NOTAG files.
# I would like the contents of the dir itself, however. Need to add files by hand.
# /home/scratch.dpanariti_t124_1/t124_1/hw/${ap_dir}/drv/simfront/Main.cpp
# !&@^%#&^@%#! //hw/${ap_dir}/include/ works if it is in this order.
# order dependence sucks.

# Adding //hw/${ap_dir}/clib causes (error Rerun etags...) problems.
if true_p "${more_depot_dirs_p}"
then
    depot_dirs_of_interest="
${depot_dirs_of_interest}
${ap_hw_p4_path}/include/
${ap_hw_p4_path}/ip/vdec/cmod/
${ap_hw_p4_path}/drv/simfront/
${ap_hw_p4_path}/drv/bootrom/
${ap_hw_p4_path}/drv/chiplib/
${ap_hw_p4_path}/clib/
${ap_hw_p4_path}/tools/RunScript/
${ap_hw_p4_path}/bin/"
fi

if true_p "${hw_dirs_p}"
then
    depot_dirs_of_interest="
${depot_dirs_of_interest}
//hw/class/
//hw/oot/
//hw/tools/mods
//hw/tools/shimlib/
//hw/kepler1_gklit3/clib/
//hw/kepler1_gklit3/diag/
//dev/cpu/tools/sim/asim/1.0/
//hw/nvgpu/inf/nvsim/2.1/clib/csl/
//hw/nvgpu/inf/nvsim/2.1/clib/include/
//hw/nvgpu/inf/nvsim/2.1/clib/nvsim/
//hw/nvgpu/inf/nvsim/2.1/clib/run_nvsim/"
fi

if true_p "${sw_dirs_p}"
then
    depot_dirs_of_interest="
${depot_dirs_of_interest}
//sw/dev/
//sw/mods/
//sw/tools/"
fi

if true_p "${fmod_dirs_p}"
then
    depot_dirs_of_interest="
${depot_dirs_of_interest}
$(me-expand-dest --normpath-term fmod)
$(me-expand-dest --normpath-term nvgpudefs)
$(me-expand-dest --normpath-term nvgpuinclude)
$(me-expand-dest --normpath-term nvgpuclib)
$(me-expand-dest --normpath-term nvgpumanuals)
//hw/nvgpu/ip/nvif/nvlink/1.0/manuals/
//hw/nvgpu/ip/nvif/nvltl/hsh1.0/manuals/"

fi

if true_p "${chip_tools_dirs_p}"
then
    chip_tools_dir=$(me-expand-dest chiptools)
    depot_dirs_of_interest="
${depot_dirs_of_interest}
${chip_tools_dir}/gmlit4
${chip_tools_dir}/gplit1
${chip_tools_dir}/common
${chip_tools_dir}/global"
fi

other_dirs_of_interest=""

EExec_verbose_echo_id ap_dir
EExec_verbose_echo_id ap_path
EExec_verbose_echo_id ap_hw_p4_path
EExec_verbose_echo_id p4_root

dirs_of_interest=$(dp4-reroot "$p4_root" $depot_dirs_of_interest)
dirs_of_interest="${dirs_of_interest} ${other_dirs_of_interest}"
EExec_verbose_echo_id dirs_of_interest

# These files change and come and go and are mostly copies of existing files.
# This kind of stuff confuses cscope.
# Sadly, my code indexing system is soooo convoluted that this is the only
# way to control the source code finder from here.
export EXCLUDE_PAT="/plex/"

if true_p "${nvcscope_p}"
then
    # St00p1d god damn mother f00ck1ng b00llsh1t a55hole 1d1ocy!
    # One tree:
    # //hw/ap_tlit1/drv/multiengine/framework/utils/loader/stream_loader.cpp
    # Another:
    # //hw/ap_tlit1/drv/multiengine/framework/utilities/loader/stream_loader.cpp
    # H0w can any thing be s0 fncking stnpid?
    ap_hw_path=$(dp4-reroot "$p4_root" "${ap_hw_p4_path}")
    #EExec_verbose_echo_id ap_hw_p4_path
    #EExec_verbose_echo_id ap_hw_path
    #EExec_verbose_echo_id dirs_of_interest
    # Filter out dirs here so we don't even look inside them.
    # Remove the ap tree since nvcscope already handles it.
    dirs_of_interest=$(filter_dirs "${ap_hw_path}" ${dirs_of_interest})
    #EExec_verbose_echo_id dirs_of_interest
    (
        link_em=t
        cd "${ap_path}"
        for cscope_file in ${nvcscope_files}
        do
          link_or_non_existent "${cscope_file}" || {
              link_em=
              dp_echo2 "$cscope_file exists and is not a link."
              break;
          }
        done
        if true_p "${link_em}"
        then
            EExec rm -f ${nvcscope_files}
            EExec nvcscope --link-this-tree-to-prebuilt-indexes
        else
            dp_echo2 "Not linking nvcscope files because of errors."
        fi
    )
fi

# Make sure we can match whole words by ensuring " "s for delimiters.
db_locs=" ${db_locs} "
for exclude in ${db_loc_excludes}
do
  db_locs=$(echo "${db_locs}" | sed -r "s! $exclude !!g")
done
EExec_verbose_echo_id db_locs
true_p "${just_show_db_locs_p}" && {
    echo "Database locations:"
    for db in ${db_locs}
    do
      vsetp "${db}" || continue
      echo -n "  ${db} -->  "
      expdb=$(me-expand-dest "${db}")
      if vunsetp "${expdb}"
      then
          echo "*** No expansion ***"
      else
          echo "$(realpath ${expdb})"
      fi
    done
    exit 0
}

doia=()
for doi in ${dirs_of_interest}
do
  doi_norm+=( $(normpath "${doi}") )
done

if ! true_p "${just_nvcscope_p}"
then
    all_indexed=
    all_db_locs=
    for db_loc in ${db_locs}
    do
      index_dirs=
      db_loc=$(me-expand-dest --normpath-term "${db_loc}")
      EExec_verbose_echo_id --msg 'Examining: ' db_loc
      [ -d "${db_loc}" ] || {
          EExec_verbose_msg "db_loc is empty."
          continue
      }
      for doi in "${doi_norm[@]}"
      do
        EExec_verbose_echo_id db_loc 
        EExec_verbose_echo_id doi
        # Select the dirs of interest under this db_loc
        # See if the dir exists or if an mexpansion of it does.
        # @todo XXX We may want to try the mexpansion first.
        [ -e "${doi}" ] || {
            # We'll just make it a requirement that any abbrevs be expanded
            # when they're added to the list of doi,s.  In many cases it is
            # expected that a lot of doi,s won't be present, and expansion
            # takes too much time.
            EExec_verbose_echo_id --msg "Non-existent: " doi
            continue

#too slow             doi=$(me-expand-dest --normpath-term "${doi}")
#too slow             EExec_verbose_echo_id --msg 'mexpanded: ' doi
#too slow             [ -e "${doi}" ] || continue
#too slow             EExec_verbose_echo_id --msg 'using mexpanded: ' doi
        }
        case "${doi}/" in
            ${db_loc}*) index_dirs="${index_dirs}
${doi}"
               EExec_verbose_echo_id --msg "   added: " doi
;;
            *) EExec_verbose_echo_id --msg "no match: " doi
               EExec_verbose_echo_id --msg "   in: " db_loc
               ;;
        esac
      done
      vunsetp "${index_dirs}" && {
          dp_echo2 "*** No dirs for db_loc>$db_loc< ***"
          continue
      }
      if true_p "${just_show_doi_p}"
      then
          echo "db location: >$db_loc<"
          dump_list "dirs to be indexed" $index_dirs
          continue
      elif true_p "${just_show_index_dirs_p}"
      then
          dump_list "dirs to be indexed" $index_dirs
          continue
      else
          EExec_verbose_echo_id db_loc
          EExec_verbose_echo_id index_dirs
      fi
      all_indexed="${all_indexed}
>${index_dirs}<"
      run_it "${bg_p}" "${db_loc}" index-code ${clean_opt} $follow_links_opt $index_dirs
      all_db_locs="${all_db_locs} ${db_loc}"
    done
    EExec_verbose_echo_id dirs_of_interest
    EExec_verbose_echo_id all_indexed
    EExec_verbose_echo_id all_db_locs

    index_out_of_tree_locations
else
    dp_echo "Not indexing non-nvcscope code."
fi

wait


true_p "${send_mail_on_completion_p}" && {
    EExec email-yopp "${progname}: completed."
}

exit
