#!/bin/sh

source script-x
set -u
progname="$(basename $0)"
source eexec
eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program

: ${sep:=,}

me_expand_dest()
{
    # Are we a majick string?
    a=($(echo "$@" | sed -rn "s/^(${sep})([^${sep}]+)(${sep})([^${sep}]*)(${sep}?)$/\2 \4/p"))
    [ "${#a}" != 0 ] && {
        eko "a:" "${a[@]}" 1>&2
        set -- "${a[@]}"
    }
    # Do dest [sb]
    local dest="${1-sb}"; shift
    local sb="${1-}"
    # Some useful special cases.
    case "${dest}" in
           .) # Go to the same place in the new sandbox.
              dest="$(dp4-location ${PWD})";;
           /) dest="sb";;     # Root
    esac

    if vsetp "${sb}"
    then
        EExec -y cd $(dogo "$sb")  # All sb roots need to be known to dogo.
    fi
    local rc
    case "${dest}" in
        //*) dest=$(echo "${dest}" | dp4-reroot); rc="$?";;
          *) dest=$(me-dogo "${dest}"); rc="$?";;
    esac
    [ "${rc}" = "0" ] || {
        echo "Cannot find>$@<"
        return 1
    } 1>&2
    shift
    [ -n "$*" ] && dest="${dest}/$@"
    dest=$(normpath "${dest}")
    echo "$dest"
    return 0
}    

me_expand_dest "$@"
