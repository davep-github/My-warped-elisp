#!/bin/sh

source script-x
set -u
progname="$(basename $0)"
source eexec
eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program

: ${sep:=,}
: ${verify_p=}

me_expand_dest()
{
    for o in "$@"
    do
      case "$1" in
          -V|--verify) verify_p=t;;
          -s|--sep|--separator) shift; sep="${1}";;
          *) break;;
      esac
      shift
    done

    # Are we a majick string?
    a=($(echo "$@" | sed -rn "s/^(${sep})([^${sep}]+)((${sep})([^${sep}]*)(${sep}?))?$/\2 \5/p"))
    EExecDashV_p && {
        echo "1st a:"
        eko "${a[@]}"
    }

    if [ "${#a}" = 0 ] 
    then
        a=($(echo "$@" | sed -rn "s|^(//[^${sep}]+)(${sep})([^${sep}]*)(${sep}?)$|\1 \3|p"))
    fi
    if [ "${#a}" != 0 ] 
    then
        set -- "${a[@]}"
    fi

    EExecDashV_p && eko "$@"
        
    # Do dest [sb]
    local dest="${1-sb}"; shift
    local sb="${1-}"
    # Some useful special cases.
    case "${dest}" in
           .) # Go to the same place in the new sandbox.
              dest="$(dp4-location ${PWD})";;
           /) dest="sb";;     # Root
    esac

    if vsetp "${sb}"
    then
        # All sb roots need to be known to dogo.
        cd $(dogo "$sb") >/dev/null 2>&1 || exit 2
    fi
    local rc
    local original_dest="${dest}"
    case "${dest}" in
        //*) dest=$(echo "${dest}" | dp4-reroot); rc="$?";;
          *) dest=$(me-dogo "${dest}"); rc="$?";;
    esac
    [ "${rc}" = "0" ] || {
        echo "Cannot find abbrev>$original_dest<"
        return 1
    } 1>&2
    shift
    [ -n "$*" ] && dest="${dest}/$@"
    dest=$(normpath "${dest}")
    if vsetp "${verify_p}" && ! [ -e "${dest}" ]
    then
        exit 1
    fi
    echo "$dest"
    return 0
}    

me_expand_dest "$@"
