#!/bin/sh

export progname="$(basename $0)"

source script-x
set -u
source eexec
eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program

EExecVerbose

csh_check()
{
    local confirmation_response="TRUST_ME"
    while (($# > 0))
    do
      case "$1" in
        --bash|--any|--bash-ok|--any-ok|--any-shell-ok) confirmation_response=t;;
        --) shift; break;;
         *) break;;
      esac
      shift
    done
            
    [ -n "$*" ] && {
        echo "$@"
    }
    confirmation_response="${confirmation_response}" csh-p || {
        if EExecDashN_p
        then
            echo
            echo "+++++++ Ignoring csh-p because EExecDashN_p"
            echo
        else
            exit 1
        fi
    }
}

csh_check --bash-ok "First check" || exit 1

: ${p4_clib_dir:=//hw/ap_tlit1/clib/Linux}
: ${log_file_base_name:=dot-sh}
# I'm done with bash because the quoting sucks beyond suckage:
# --egrep 'ERROR: cannot aquire /tmp/asim.X'
# --egrep 'something bad happened'}
# --cflush-every=-1 --> flush to zip every line.
: ${teeker_options=--slog -Z9 --ts --hg -i100 --cflush-every=-1}
: ${teeker_regexps=--hgrep plugin --hgrep __Startup --hgrep __Initialize --hgrep surface_write_read: --hgrep mem_txn_swr: --hgrep dp-msg:}
: ${testname=}
: ${yopp_p=t}

check_test()
{
    local testname="$@"
    local rc=1

    echo "Checking test candidate>$@<"
    if [ -z "${testname}" ]
    then
        echo 'testname is empty'
    elif (($(echo "$@" | wc -w) > 1))
    then
        echo "More than one executable file found."
    elif test -d "${testname}"
    then
        echo "${testname} is a dir."
    elif ! test -x "${testname}"
    then
        echo "${testname} is not executable."
    else
        rc=0
    fi
    return "$rc"
}

[ -e /tmp/asim.* ] && {
    echo
    echo "ERROR: /tmp/asim.X exists:"
    ls -1 /tmp/asim.*
    echo
    exit 1
} 1>&2

if vunsetp "${testname}"
then
    case "${1-}" in
        -|.|--) shift;;
        -*|"") ;;
        *) testname="${1}"; shift ;;
    esac
    vunsetp "${testname}" && {
        # In a dir like:
        # /home/scratch.dpanariti_t124_1/sb3/sb3hw/hw/ap_t132/diag/testgen/dp-run-tgens.d/swr_so_runlimit/2013-08-16T18.26.17-0400.out/tests/kepler_b_ogtest/00/00/01/000001
        testname=$(pwd | sed -rn 's!(^.*/dp-run-tgens.d/)([^/]+)(/.*)!\2!p')
        #echo_id testname
        vsetp "${testname}" && testname="${testname}.sh"
        if ! check_test "$testname"
        then
            testname=$(ls -1 *.sh | egrep -v '^(command|.*\.cmd)\.sh$')
            #echo_id testname
            if ! check_test "${testname}"
            then
                echo "$progname: No test name given and cannot guess a good default.
Usage:  testname [additional-teeker-options]"
                exit 1
            fi 1>&2
        fi
        echo "Deduced test name>${testname}<"
    }
fi

# The "something bad happened" problem when running RTL
# (top_peatrans_gpurtl)seems to be related running in my bash environment.
# So we check for RTL signatures in the dot sh file and csh-p if they're found
if egrep -q -e "top_peatrans_gpurtl" "${testname}"
then
    csh_check "RTL found"
fi

test_base_name=$(basename "${testname}" .sh)
fgrep 1>/dev/null 2>&1 -- ' -gdb ' "${testname}" && {
    echo
    echo "ERROR: ${testname} contains a -gdb option. Exiting."
    echo
    exit 1
} 1>&2

cfg_file_name="${test_base_name}.cfg"
so_name=$(sed -rn "s/(.*-plugin ')([^[:space:]]+)( .*)/\2/p" "${cfg_file_name}").so
#echo_id so_name
clib_dir=$(me-expand-dest "${p4_clib_dir}")
so_path="${clib_dir}/${so_name}"
#echo_id so_path
# Check for no go&^@*(#amn(*#&(#*&$other-*&^#*$&-ing link errors.
#ldd "${so_path}"
#echo "Finish writing ldd check!"

# E.g. ./surface_write_read_no_smmu_bar1.sh 2>&1 | teeker --slog -Z9 --ts --grep 'surface_write_read:' --hg dot-sh --egrep 'ERROR: cannot aquire /tmp'; email-yopp

EExec "${testname}" 2>&1 | EExec teeker ${teeker_regexps} ${teeker_options} "$@" "${log_file_base_name}"
rc="$?"

if vtruep "${yopp_p}"
then
    EExec email-yopp "$progname: \"${testname} $@\" is done. RC: $rc"
else
    echo "Not yopp'ing."
fi
