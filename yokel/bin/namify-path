#!/bin/sh
# $Id: namify-path,v 1.5 2005/02/28 08:11:13 davep Exp $
#
# Convert a pathname to a filename by substituting / chars with
#  another char, which defaults to '.'
#set -x
. script-x
char="."
no_leading_char=""

Usage()
{
    echo "Usage: $(basename $0) {-[nlh]} {-[cds] <new-char>} <path-name>
Replace / characters in <path-name> with <new-char> or '.'
-h --> Show this message and exit.
-n --> Nuke a leading / (actually its replacement) from the result.
-l --> Leave a leading /'s replacement.
-[cds] <char> --> The char which will replace the /."
    
    exit "$1"
}

Error()
{
    [ -z "$@" ] && set -- 1
    Usage "$@" 1>&2
}

option_str="nlhc:d:s:/"
q=$(getopt -o "$option_str" -- "$@")
[ $? != 0 ] && Usage 1          # This is a misteak.
eval set -- "$q" 

[ $? != 0 ] && Error 1

for i in $*
do
    case $1 in
	-n|'-/') no_leading_char=t ;;
	-l) no_leading_char= ;;
        -h) Usage 0;;           # This is a request
	-c|-d|-s) char=$2; shift;;
	--) shift; break ;;
	*) exit 1 ;;
    esac
    shift
done

path=$1
path=$(echo $path | sed 's!//*$!/!')
base=$(echo $path | sed "s!/!$char!g")

if [ "$no_leading_char" != "t" ]
then
    echo $base
else
    echo $base | sed "s!^\\$char!!"
fi

