#-*-Shell-script-*-
# source me.

# @todo XXX change complete with something that works in bash but doesn't
# make zsh barf.

# DP_BASH_ONLY()
# {
#     "$@"
# }

gnu_global_complete()
{
        local cur
        cur=${COMP_WORDS[COMP_CWORD]}
        COMPREPLY=($(global -c $cur))
}
complete -F gnu_global_complete global

dp_binaries_complete()
{
        local cur
        cur=${COMP_WORDS[COMP_CWORD]}
        COMPREPLY=($(compgen -c $cur))
}
complete -F dp_binaries_complete sp run-iff xit lessit

# Ripped off from /bfd/sundry/davep/RCS/RCS.sam/home.davep/.rc/bash_completion,v
# I know not from whence it originally came.
# @(...) is an extended glob (extglob)
_dp_sp_complete()
{
    #set -x
    local words cword
    local cur=${COMP_WORDS[COMP_CWORD]}
    local prev=${COMP_WORDS[COMP_CWORD-1]}

    {
	echo "COMP_WORDS>${COMP_WORDS[@]}<"
	echo "COMP_TYPE>${COMP_TYPE}<"
    } 1>&2
    local i
    for (( i=1; i <= COMP_CWORD; i++ )); do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            local root_command=${COMP_WORDS[i]}
            _command_offset $i
            return
        fi
        [[ ${COMP_WORDS[i]} == -@([0-9]|l|ll|r|x|f|v|F|e|L|g|G|d|S) ]] && ((i++))
    done

    case "$prev" in
        -x)
	    cur=${COMP_WORDS[COMP_CWORD]}
            COMPREPLY=($(compgen -c $cur))
            return
            ;;
        -X|-f)
            # argument required but no completions available
            return
            ;;
    esac

    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $( compgen -W '-1 -2 -3 -4 -5 -6 -7 -8 -9
            -x -X -f
            -l -ll -r -v -F -e -g -G -d -s' -- "$cur" ) )
        return
    fi
}
complete -F _dp_sp_complete sp

#
# I copped most of this and hacked it, but I don't really know how it works.
# :-(
# AH!  Just remembered.
_dp_sp_complete_hide()
{
    _dp_sp_complete_exp_guts "$@"
}

dp_go_complete()
{
        local cur
        cur=${COMP_WORDS[COMP_CWORD]}
        COMPREPLY=($(go2env --grep-name-only "^$cur"))
}
complete -F dp_go_complete g go dogo

dp_ctags_etags_expand()
{
    local cur="$1"
    local tag_file
    tag_file=$(find-up TAGS-tags)
    if [ -n "${tag_file}" ]
    then
        COMPREPLY=($(\egrep "^$cur" "${tag_file}"))
        return
    fi

    tag_file=$(find-up TAGS)
    if [ -n "${tag_file}" ]
        then
#set -x
        COMPREPLY=($(get-ex-etags-tags "${tag_file}" | \egrep "^$cur"))
#set +x
        return
    fi
    return 1
}

dp_ctags_etags_complete()
{
        local cur
        cur=${COMP_WORDS[COMP_CWORD]}
        dp_ctags_etags_expand "${cur}"
}

# I have a pass routine of my own.  Treat it like pass.
# I though I had hijacked a completion function for which I had written a
# front end.  Can't make it work now.
# complete -o filenames -F _pass cpass

true
