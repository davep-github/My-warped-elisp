# Meant to be sourced.
# Shared with root.

#echo 1>&2  "YOPP! top of ~/bin/func.root SHELL>$SHELL< ***************************************************"

#
# These need to be here so that programs can use them.
# I need to change all invocations to not use aliases.
#
echo "$(date):func.root" >> /tmp/func.root.sourcings

# vsetp & friends moved to func.early.
# this is sure to cause problems.
function settrue()
{
    local varname="${1}"
    shift
    local export=
    if test "${varname}" = "-e" 
    then
        export=export
        varname="${1}"
        shift
    fi
    eval eval $export \$varname=t
}

function sed_cd()
{
    cd $(sed_path "$@")
}
DP_EXPORT_FUNC sed_cd
alias cd-sed=sed_cd
alias xcd=sed_cd

function sed_go()
{
    g $(sed_path "$@")
}
DP_EXPORT_FUNC sed_go
alias xdir=sed_go
# go grep
alias gg=sed_go

# Exchange sandboxes

function exchange_sandboxes()
{
    [ -z "${1-}" ] && {
        echo "exchange_sandboxes(): Need a box name."
        return 1
    } 1>&2

    xdir "$(scsandbox $PWD)" "$1"

    # Is there another arg? That's a directory to `gr' to.
    [ -n "${2-}" ] && {
        gr "$2"
    }
}
DP_EXPORT_FUNC exchange_sandboxes
alias xsb=exchange_sandboxes

function sedp()
{
    pushd $(sed-path "$@")
}
DP_EXPORT_FUNC sedp

function bglq()
{
    echo "#$(date): $@" >> "$BGLQ_LOG"
    beagle-query "$@" | grep -v "file:///sundry/davep/beagle-config" \
        | sed -r 's!^([0-9]+:)?file://(/[^#]*)(.*)$!\2!' \
        | tee /tmp/bglq-last.out
}
DP_EXPORT_FUNC bglq

function dp_kill_job_id_n()
{
#set -x
    local jidn="$1"
    local jid="%$1"
    shift
    local sig=${1:--15}
    kill "$sig" "$jid" && wait "$jid"
    if jobs | fgrep -q "[$jidn]"
    then
	kill -9 "$jid" && wait "$jid"
    fi
}
DP_EXPORT_FUNC dp_kill_job_id_n 

true ${DP_DEF_PIX_ARGS:=-FASs}
true ${DP_PIX_COLORIZE:=-F}
function pix()
{
    # pix + Installed check
    local opts
    local less_opt
    if [[ "$1" != "-l" ]]; then
	less_opt="| less"
    else
	less_opt=""
	shift
    fi
    case "$1" in
      -*) opts=;;
      *) opts="${DP_DEF_PIX_ARGS}";;
    esac

    eval eix $DP_PIX_COLORIZE $opts "$@" $less_opt
}

function pixi()
{
    # pix + Installed check
    local opts
    local less_opt
    if [[ "$1" != "-l" ]]; then
	less_opt="| less"
    else
	less_opt=""
	shift
    fi
    case "$1" in
      -*) opts=;;
      *) opts="${DP_DEF_PIX_ARGS} -I";;
    esac

    eval eix "$opts" "$@" $less_opt
}
DP_EXPORT_FUNC pixi
alias ipix=pixi

function dashify()
{
    ret=
    for o in $*; do
        # echo 1>&2 "o>$o<"
        case "$o" in
            "") ;;              # Should not happen, but...
            " ") ;;
            -*) ret="$ret $o";;
            *)  ret="$ret -$o";;
        esac
    done
    echo "$ret"
}
DP_EXPORT_FUNC dashify

alias akrord=acroread

function grep_var_log_messages()
{
    if [[ "$1" == -HIGH_LAST ]]; then
	shift
	first=$(ls -1 /var/log/messages.[0-9]*)
	first_grep=zgrep
	last=/var/log/messages
	last_grep=grep
    else
	first=/var/log/messages
	first_grep=grep
	last=$(ls -1r /var/log/messages.[0-9]*)
	last_grep=zgrep
    fi
    sudo $first_grep "$@" $first $last
    sudo $last_grep "$@" $first $last
}

function page_tail()
{
    local lines
    if [[ "$1" =~ ^[0-9]+$ ]]
    then
        lines="$1"
        shift
    else
        # Deduct 2 for my prompt.
        lines=$((${LINES:-25} - 2))
    fi

    tail -n "${lines}" "$@"
}

function page_of_history()
{
    local lines
    if [[ -z "$*" ]]; then
        local lines=$((${LINES:-25} - 2))
    elif [[ "$1" =~ ^-?[0-9]+$ ]]
    then
        lines="$1"
        [[ "$1" =~ ^- ]] && lines=$(echo "$1" | cut -c 2-)
        shift
    else
        # Don't know what they want.  Pass it on to fc.
        fc "$@"
        return 1
    fi
    fc -l -$lines
}
DP_EXPORT_FUNC page_of_history
DP_BASH_ONLY typeset -f -x page_of_history

function demerge()
{
    local ask="--ask"
    [ "$1" == "-a" -o "$1" == '-y' ] && {
	ask=""
	shift
    }   
    emerge --depclean --verbose $ask "$@" || {
	echo "Emerge refused to depclean... runing equery..."
	equery d "$@"  # This may barf if any extra emerge options are used.
    } 1>&2
}
DP_EXPORT_FUNC demerge
alias delmerge=demerge
alias unmerge=demerge

function dp_ternary()
{
    local rc=$(eval "${1}" && echo "true" || echo "false")
    echo "${rc}"
    ${rc}
}
# Linux's /bin/kill does this, but wrap it in case others don't and we need
# to write it.

alias dp_exxit='set +; exit '

# A good test:
# $ exit-with-x $((128 + <some-signal-num>))
# $ exit-with-x $(( somethin < 128 ))


true ${DPBRC_Clear_set_x_p=t}
export DPBRC_Clear_set_x_p
true ${DPBRC_Show_rc_in_prompt_p=t}
export DPBRC_Show_rc_in_prompt_p
true ${DPBRC_Verbose_rc_in_prompt_p=t}
export DPBRC_Verbose_rc_in_prompt_p
#echo_id2 DPBRC_set_x_post_prompt_command_val
#echo 1>&2 "\$0>$0<"
true ${DPBRC_set_x_post_prompt_command_val='+x'}
export DPBRC_set_x_post_prompt_command_val

# @todo XXX errno(dp) is suffering from a very mysterious bit-rot.
#echo 1>&2 "DPBRC_set_x_post_prompt_command_val>$DPBRC_set_x_post_prompt_command_val<"
#progs don't return errnos. function prompt_command_errno()
#progs don't return errnos. {
#progs don't return errnos.     if vsetp ${dp_verbose_rc_in_prompt_p-}; then
#progs don't return errnos.         if [ "${1-}" == 0 ]; then
#progs don't return errnos.             echo 0
#progs don't return errnos.         else
#progs don't return errnos.             echo "$1:$(errno -n ""$1"")"
#progs don't return errnos.         fi
#progs don't return errnos.     else
#progs don't return errnos.         echo "$1"
#progs don't return errnos.     fi
#progs don't return errnos. }

# Just print the return code as a number.
function prompt_command_errno()
{
    echo "${1-0}"
}

#
# Move this to func?
#
function prompt_command()
{
    # Status is still set from the last command.
    local rc="$?"
    # This is now in a script that is imported to define a function
    PS1_path_suffix=$(dp_stolen__git_ps1)
    PS1_terminator="$BASE_PS1_terminator"
    # Have 0, the most common rc, be plain and simple.
    if [ "$rc" != 0 ]; then
	# @todo XXX the check for rc in signal range is done in decode.
	# Remove it here when I'm not so gdmf tired.
	if vsetp DPBRC_Verbose_rc_in_prompt_p
	then
	    rc_str="$(dp_decode_cmd_status $rc)"
	else
	    rc_str=$(prompt_command_errno "$rc")
	fi
	if vsetp "$DPBRC_Show_rc_in_prompt_p"; then
	    PS1_terminator='<'"$rc_str$PS1_terminator"
	fi
    fi
    # Need to use utils to get the same effect as PS* escapes.
    # Or to get that fucking prompt as a whole to work!
    #local x
    #eval x="$PS1_line0"
    #echo "$x"  
    eval title_bar_titler "$XTerm_title" || {
	: echo -n "$*" >/dev/tty
    }
    dp_set_x_fini

    return $rc
}
export PROMPT_COMMAND=prompt_command
DP_EXPORT_FUNC prompt_command

function pathff()
{
    PATH=$(cat "$@")
}
DP_EXPORT_FUNC pathff

# Copped from GIT shell on Windwoes.
export dp_sourcing=t
source $HOME/bin/dp_stolen__git_ps1
DP_EXPORT_FUNC dp_stolen__git_ps1

function __gitdir() 
{ 
    if [ -z "${1-}" ]; then
        if [ -n "${__git_dir-}" ]; then
            echo "$__git_dir";
        else
            if [ -d .git ]; then
                echo .git;
            else
                git rev-parse --git-dir 2>/dev/null;
            fi;
        fi;
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}

function newest_base()
{
    local op="${1}"; shift
    local depth=1
    local nth=
    while (($# > 0))
    do
      case "${1-}" in
          -n|--nth|--depth) shift; depth="${1}";;
          x[0-9]*|[0-9]*) depth="${1}";;
          -[0-9]*) nth="${1}";;
          --) shift; break;;
          *) break;;
      esac
      shift
    done
    local dir
    while ((depth-- > 0))
    do
      dir=$(newest-dir ${nth} "$@") || return $?
      $op "${dir}" || return $?
    done
    return "$?"
}

function cdnew()
{
    newest_base cd "$@"
    return "$?"
}
DP_EXPORT_FUNC cdnew
alias cd_newest=cdnew

function go_newest()
{
    newest_base g "$@"
    return "$?"
}
DP_EXPORT_FUNC go_newest
alias gonew=go_newest

function xxx_newto()
{
    local op="${1}"; shift
    local dest
    dest=$(cdnewto.sh "$@") || {
        return "$?"
    }
    "${op}" "${dest}"
    return 0
}
DP_EXPORT_FUNC xxx_newto

function cdnewto()
{
    xxx_newto cd "$@"
    return "$?"
}
DP_EXPORT_FUNC cdnewto

function gnewto()
{
    xxx_newto g "$@"
    return "$?"
}
DP_EXPORT_FUNC gnewto

#echo 1>&2 "YOPP! end of ~/bin/func.root SHELL>$SHELL< ***************************************************"
true
