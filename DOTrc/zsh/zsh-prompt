#-*-shell-script-*-

# @todo XXX I need to make this whole file work during a root login.
# see man zshmisc.  D'uh.
# echo 1>&2 "zsh-prompt: DP_ZSH_ENVIRONMENT_FUCKED>$DP_ZSH_ENVIRONMENT_FUCKED<"
# echo 1>&2 "zsh-prompt: DP_ZSH_FIX_FUCKED_ENVIRONMENT>$DP_ZSH_FIX_FUCKED_ENVIRONMENT<"

#
# Setup the normal prompt.
# In Emacs shell buffers, the prompt is parsed to track the current
# directory, so it must have the current working directory (aka `default-directory') in it somewhere. [ at this time: 2021-03-25T15:09:34 ] the regexp I use to extract the cwd is:
# "^$(user)@$(machine):\\([~/][[:graph:]]*\\)\\(.*\\)$"
# for some reason, when the prompt string is read by comint before being sent
# to the recognition routine, it looks like garbage, serious garbage, all
# garbage, ?all? non-ASCII.  Hopefully it's due to the colorization, so lets
# turn that off in Emacs' shells.
# I want to do different things with colors, etc, in Emacs.  Do we know by
# now if we're here.
true ${PS1_backup=$PS1}; export PS1_backup
true ${PROMPT_backup=$PROMPT}; export PROMPT_backup
setopt PROMPT_SUBST
unset PROMPT
# @todo XXX use inside_emacs_p() to make Emacs specific mods to prompt, etc.
# DP_XTITLE_ID always goes first so wmctrl(1), or other similar, can ID the
# window easily. The `!' is part of the ID to make it more unique.  I don't
# think wmctrl, et. al., use regexps.
# @todo XXX ??? Have an [associative] array to hold arbitrary prefix
# indicators.  The hash is best because then we can unset the prefix by name.
# Display them as sorted by name or key or hash order?
decorated_NH_indicator=
export GIT_PROMPT='${dp_NH_indicator}%B%n@%m:%~%b'
# We need to match the form of the bash prompt for emacs shell-buffer dir
# tracking.  In fact all shells should do the same.
# [ at this time: 2020-11-02T11:17:53 ] zsh and shell mode don't get along.
# zsh outputs what looks like garbage when printing the prompt.  The comint
# filter sees garbage but the shell buffer shows the expected prompt
# containing the properly formatted prompt.  However since the filter
# function doesn't see the right thing it can't track the dir.  The garbage
# doesn't look like the raw prompt, but it could be some "compiled" form.
# [(nh)]user@host:(c/w/d -OR- ~/w/d) [(git-branch[git-modified-indicator])]<actual newline>
# (SHLVL:zsh) hist-num(> -OR- <error-code>) "
# It's incredibly slow for large projects.
# Need a way to switch to it, hopefull automagically.
# Anyway to get git project size?
export NO_GIT_PROMPT=${GIT_PROMPT}
function git_prompt_info_no_stat()
{
    local gcb=$(git_current_branch)
    if [[ -n "${gcb}" ]]
    then
	gcb="(${gcb})<-*->"
    fi
    echo "${gcb}"
}
NO_GIT_PROMPT+=' $(git_prompt_info_no_stat)'
GIT_PROMPT+=' $(git_prompt_info)'

if [[ "$(id -u)" == 0 ]]
then
    # ~I am root.~
    line2_color="red"
else
    line2_color="cyan"
fi

function precmd() {
    # See, the internet *is* useful.
    # In a prompt string, %v expands to the value of psvar.
    psvar=$(dp_decode_cmd_status $?)
}

final_prompt_part="%F{${line2_color}}(${SHLVL}:zsh) %!%(0?||<%S%v%s)>%f "
GIT_PROMPT+="
${final_prompt_part}"
NO_GIT_PROMPT+="
${final_prompt_part}"

PROMPT="${GIT_PROMPT}"

ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg_bold[white]%}(%{$fg[white]%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%} "
ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[white]%})%{$fg[red]%}"
# @todo XXX Change the dirty indicator back to only one unicode character if
# we can determine unicode support.  lxterm(1) claims to do that and use the
# proper terminal, but doesn't.
# If we can tell the difference twixt ASCII vs unicode, then we can choose
# what to use for dirty, and other special states.
ZSH_THEME_GIT_PROMPT_DIRTY+="*âœ—*"
ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg[white]%})"

# Here is where we [WILL] be able to setup different prompts for different
# environments. E.g. turn off fancy colors and things like the git status
# char.  Places like Emacs shells.
# But for now:

true
