#!/bin/sh

progname=$(basename $0)
. script-x
. eexec
. code-indexing.rc


midix=
vsetp $PROJECT && midix=.${PROJECT}


: ${RC_FILE_OVERRIDE=}
: ${RC_FILE_NAMES=".../DOTindex-code.rc .../DOTindex-code${midix}.rc"}
: ${RC_EXTRA_FILE_NAMES=}
: ${RC_START_DIR:=$PWD}
: ${RC_STOP_DIR:=${PROJECT_ROOT:=$HOME}}

# rc file variables should be prefixed with rc_
# This is a list of extra dirs to index provided by any possible rc files.
rc_dirs=

#
# Bummer. Want this read first, to let options override values set in rc files.
# But 2 options, RC_STOP|START_DIR control *this* operation.
# Must use the envvars.
if vsetp $RC_FILE_OVERRIDE      # Let this override all
then
    slist="$RC_FILE_OVERRIDE"
else
    rc_file_names=
    for rc_file in $RC_FILE_NAMES
    do
      d=$(dirname "$rc_file")
      if [ "$d" == "..." ]
          then
          name=$(basename $rc_file)
          rc_files=$(files-here-and-up "$name" $RC_START_DIR $RC_STOP_DIR) || {
              echo 1>&2 "$progname: Error finding ancestral list of rc files."
              exit 1
          }
          for rcf in $rc_files
          do
            [ -x "$rcf" ] && {
                source "$rcf"
            }
          done
      fi
    done
fi
echo_id slist
vsetp $slist && source_list "" $slist
echo_id rc_dirs

# main_machine="excuses-and-accusations"
# type -p realpath >/dev/null 2>&1 || {
#     echo 1>&2 "$progname: realpath not found; indexing on $main_machine."
#     ssh excuses-and-accusations "cd $PWD; $0 $@"
#     exit
# }

prog=`basename $0`

Usage()
{
   {
       echo "${prog}: usage: [-$all_options]"
   } 1>&2
   
   exit 1
}

AND_INDEX="and index"

: ${ciflags_def:="-am"}
: ${ciflags:="$ciflags_def"}
: ${tflags:=""}
: ${gtflags:=""}
: ${amper:="&"}
: ${clean:="$AND_INDEX"}
: ${real_paths:=t}
: ${no_gtags_p:=t}
: ${ctags_p:=t}
: ${etags_p:=t}
: ${tree_tagger:=extagtree}
: ${DEF_SYSTEM_INCLUDES:=/usr/include}
: ${finder_opts:=} # Bad design: this is a parameter to the source code finder.
export finder_opts

SYSTEM_INCLUDES=
# init optional vars to defaults here...
VERBOSE=:
DEBUG=:
output_dir=
MV=$(sp -1 mv) || {             # Avoid -i type aliaii
    dpe_echo 1 "Cannot find \"mv\" in the path."
}

iterate_individually_p=

option_str="nvdc:t:g:CTkKVo:Gxeiuf:Is:S:"  # <:add new options:>
all_options="$option_str$std_options"

q=$(getopt -o "$all_options" -- "$@")
[ $? != 0 ] && Usage
eval set -- "$q" 
unset q

for i in "$@"
do
  # do. e.g.  $OPTION_ARG=$2; shift;; to process options with arguments.
  case $1 in
      -I) iterate_individually_p=t;;
      -n) EXEC=echo; EExecDashN;; # Don't actually execute stuff
      -v) VERBOSE="echo $prog: "; EExecVerbose;;
      -V) cscope_indexer_verbose='-v';;
      # -d is really just verbosity
      -d) EExecVerbose; DEBUG="echo 1>&2 $prog: ";;
      -t) tflags="$tflags $2"; shift;;
      -t) if [[ "$2" =~ "^--?$" ]]; then 
             gtflags=""
          else
             gtflags="$gtflags $2";
          fi
          shift;;
      -c) ciflags="$ciflags $2"; shift;;
      -T) tflags="";;
      -D) ciflags="";;
      -K) clean="$AND_INDEX";;
      -k) clean=t;;
      -G) no_gtags_p=t;;
      -o) output_dir=$(realpath $2); shift;;
      -x) ctags_p=$(invert_flag $ctags_p);;
      -e) etags_p=$(invert_flag $etags_p);;
      -i) SYSTEM_INCLUDES="$DEF_SYSTEM_INCLUDES";;
      -u) export src_code_finder=uds-files;;
      -f) finder_opts="$finder_opts $2"; shift;;
      -s) shift; RC_STOP_DIR=$1;;  # Stop is more likely to change.
      -S) shift; RC_START_DIR=$1;;  # Stop is more likely to change.
      --) shift ; break ;;
      *) 
      echo 1>&2 "Unsupported option>$1<";
      Usage
      exit 1 ;;
    esac
    shift
done
: ${dirs:="$@"}
: ${dirs:="$PWD"}

# Put the system includes first so any collisions will be noticeable.
dirs="$SYSTEM_INCLUDES $dirs $rc_dirs"

vsetp "$real_paths" && {
#     ndirs=
#     for d in $dirs; do
#         ndirs="$ndirs $(realpath $d)"
#     done
#     dirs="$ndirs"
    dirs=$(for d in $dirs; do
               realpath $d
           done)
}
echo_id dirs 

exit_p=
for d in $dirs
do
  [ -e "$d" ] || {
      echo "$d does not exist."
      exit_p=1
  } 1>&2
  [ -d "$d" ] || {
      echo "$d is not a dir."
      exit_p=1
  } 1>&2
done
vsetp $exit_p && {
    exit $exit_p
}

if [[ -n "$clean" ]]
then
    rm -f $index_files || {
        echo "rc of index files>$index_files<, failed."
        exit
    } 1>&2
    [ "$clean" = "$AND_INDEX" ] || {
        exit 0
    }
fi

gtagser=$(sp -1 gtags)
[[ -z "$no_gtags_p" && -n "$gtagser" ]] && {
    EExec eval gtagtree $gtflags $dirs $amper
}

# extagtree defaults to making etags compatible files.  -E inverts this.
# [ -n "$ctags_p" ] && EExec eval ${tree_tagger} -E $tflags $dirs $amper
# [ -n "$etags_p" ] && EExec eval ${tree_tagger} $tflags $dirs $amper
# EExec eval '( rm -f cscope.* && cscope-indexer $cscope_indexer_verbose -r $ciflags $dirs )'
# [ "$amper" = "&" ] && {
#     echo "waiting for procs to complete..."
#     wait
# }

do_taggin()
{
    local dirs="$@"
    echo 1>&2 "This ($(basename $0)), ${tree_tagger} and cscope-indexer need to be reworked.
They should work off the same set of files."
    EExec eval ${tree_tagger} $DP_SCRIPT_X_DEBUG_OPT $tflags $dirs
    echo "taggin in $PWD"
    if vsetp "$output_dir"
    then
        EExec $MV $index_files "$output_dir"
    fi
}

if vsetp $iterate_individually_p
then
    # Make individual indices in each specified dir.
    for d in $dirs
    do
      (cd "$d" && do_taggin) &
    done
    wait
else
    do_taggin $dirs
fi
echo "index-code done: $(date)."
