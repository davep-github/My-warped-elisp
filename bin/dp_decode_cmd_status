#!/usr/bin/env bash

# Decode a program's exit code.
# E.g. < 128 is a return code.
#      > 128 is a signal error code.
#      == 128 looks like 0, no I make it pseudoSIG0, since 128 isn't zero,
#      but looks like it after mod'ing.
function dp_decode_cmd_status()
{
    #echo "===========\$?>$?<=========="
    local prefix=""
    [[ "$1" == "--zsh" ]] && {
	prefix="<"
	shift
    }
    local rc="${1-$?}"; shift
    local signum_min=128
    local signame="SIGNAME_UNSET"
    local signum=$((${rc} - ${signum_min}))
    local num_sigs=$(/bin/kill -l | wc -w)
    local pstr="pstr UNSET!"

    # User return codes should not be >= 128.
    if [[ "${rc}" == "99" ]]
    then
	pstr="dp(1) debug exit"
    elif (("${rc}" <= "${signum_min}"))
    then
	# Special case to separate 128 from 0 (128 - 128)
	if [[ "${rc}" == "${signum_min}" ]]
	then
	    # @todo XXX Is this a good idea?
	    # This is informational only, anyway.
	    pstr="pseudoSIG0"
	else
	    pstr="${rc}"
	fi
	rc="${rc}"
    elif ((${signum} > ${num_sigs}))
    then
	# Is the signum > max signum?
	pstr="Illegal SIGNUM:$rc"
	rc=1
    elif  signame=$(/bin/kill -l "${signum}") 2>/dev/null
    then
	# Did kill find the signum pleasing?
	# We already know the code isn't too big.
	# zsh and bash have builtin kill commands that display
	# the list of signals differently.
	pstr="SIG${signame}"
	rc=0
    else
	pstr="${rc}: EINVAL: confuzed"
	# Eat the effing rc, MFer.
	# rc=$rc
    fi
    echo "${prefix}${pstr}"
    # Eat the effing rc, MFer.
    return "${rc}"
}

# Makes it nice if I want to source this like a lib function
dp_decode_cmd_status "$@"
