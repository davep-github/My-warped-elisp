#!/usr/bin/env bash
########################################################################
#
# template begins. NOT.
# Need a zsh template.
#
#
# template end.
########################################################################
# Take the output of type and visit the file if possible.
# I made this a zsh script because zsh's less, while incompatible, has better
# functionality.  E.g.
# $ type less ->
# less is /bin/less
#         =========
# $ type add_rc_text -->
# add_rc_text is a shell function from /home/davep/.rc/dp-rc-debug
#                                      ===========================
# Alias types are problematical
# $ type xsb -->
# xsb is an alias for exchange_sandboxes
# No filename.  Need to grep for it, but at least I know where/what to grep.
#

# davep specific code begin -------------8><------------------
source script-x
set -u
progname="$(basename $0)"
source eexec
if [[ -n "${eexec_program-}" ]] # Did the caller provide a program?
then
    EEXEC_SHIFT=:
else
    eexec_program=$(EExec_parse "$@")
    EEXEC_SHIFT=shift
fi

for op in $eexec_program
do
  $op
  ${EEXEC_SHIFT}
done
EExec_verbose_msg $(echo_id eexec_program)
unset eexec_program

function with_saved_rc()
{
    local rc="$?"
    "$@"
    return "${rc}"
}

# WTF are you?
function xxx_recognizer()
{
    EExecVerbose_p && eko "in xxx_recognizer() \$#: $#" "$@"
    local sed_regexp="${1-}"; shift
    local type_command_results="${1-}"; shift
    EExec_verbose_msg "$0: echo \"${type_command_results}\" | sed -rn \"${sed_regexp}\""
    local sed_response=$(echo "${type_command_results}" | sed -rn "${sed_regexp}")
    local rc="$?"
    EExecVerbose_p && with_saved_rc echo "sed_response>${sed_response}<"
    with_saved_rc echo "${sed_response}"
    return $rc
}

# function:
# running_as_script is a shell function from /home/davep/.rc/func
function func_recognizer()
{
    EExecVerbose_p && eko "in func_recognizer()" "$@"
    local typee_base="${1}"; shift
    local xxx_regexp="s/(${typee_base}"' is a shell function from )(.*$)/\2/p'

    xxx_recognizer "${xxx_regexp}" "$@"
}

# file:
# (ec-type-zsh is )(/home/davep/bin/ec-type-zsh<)
function file_recognizer()
{
    press-enter-to-continue "File recognizer: "
    EExecVerbose_p && eko "in file_recognizer()" "$@"
    local typee_base="${1}"; shift
    local xxx_regexp="s/(${typee_base}"' is )(.*$)/\2/p'

    xxx_recognizer "${xxx_regexp}" "$@"
}

# alias:
# xsb is an alias for exchange_sandboxes
function alias_recognizer()
{
    local cmd="${3}"
    EExecVerbose_p && eko "in alias_recognizer()" "$@"
    for f in ${locale_rcs}
    do
	local lf=$(normpath "${DP_RC_DIR}/alias${f}")
	[[ -e "${lf}" ]] || continue
	EExec -q fgrep -n "alias=${cmd}" "$lf"
    done
    # local typee_base="${1}"; shift
    # local alias_regexp="s/(${typee_base}"' is an alias for )(.*$)/\2/p'
    # # We can't (lazily)  know an alias's defining file.
    # local file_says=$(EExec xxx_recognizer "${alias_regexp}" "$@")
    # if [[ -n "${file_says}" ]]
    # then
    # 	echo "$@: is an alias. Not looking for it's file yet."
    # 	# "A successful failure."
    # 	exit 2
    # fi
}

recognizers=(
    "func_recognizer"
    "file_recognizer"
    "alias_recognizer"
)

function ec-type-zsh()
{
    typee=${1-}; shift
    true "${op:=ec}"
    [[ -z "${typee}" ]] && {
	echo "$progname: wants a runnable thing's name."
	exit 1
    } 1>&2

    local typee_base=$(basename "${typee}")
    local file_to_edit=''

    # zsh doesn't see our aliases.
    exe_type=$(zsh -c "type ${typee}")
    EExec_verbose_msg "typee_base>${typee_base}<
    	exe_type>${exe_type}<"

    for recognizer in "${recognizers[@]}"
    do
	echo "${recognizer} <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"

	EExec_verbose_msg "recognizer>${recognizer}<"

	file_to_edit=$("${recognizer}" "${typee_base}" "${exe_type}" "${typee}")

	local rc="$?"
	##EExec_verbose_msg "1:file_to_edit>${file_to_edit}<"
	# read "bubba?3:Press enter> "
	(( "$rc" == 0 ))  || {
    	    EExec_verbose_msg "func_recognizer ${exe_type} failed: $rc"
    	    exit $rc
	} 1>&2

	EExec_verbose_msg "

2:file_to_edit>${file_to_edit}<

"
	continue
	if [[ -n "${file_to_edit}" ]]
	then
	    EExec "${op}" "${file_to_edit}"
	    press-enter-to-continue "Post op>${op}< >${file_to_edit}<: "
	    # We want ec(dp)'s return code.
	    exit
	else
	    echo "No file to >${op}< this loop: ${recognizer}"
	fi
    done
    false
}

(($# > 0)) || {
    echo "Usage: ${progname} runnable...
Visit or show file of runnable.  E.g. the file if executable,
the file in which a shell function was defined.
Or just print the fact the runnable is an alias.  grep(1) for it yourself."
    exit 1
} 1>&2

ec-type-zsh "$@" || {
    echo "$progname: couldn't find a file to edit."
    false
} 1>&2
