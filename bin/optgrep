#!/usr/bin/env zsh
########################################################################
#
# template begin.
#emulate bash
# With the emulate bash uncommented, I get this error:
# (zsh) 2856> optgrep hashlistall
# /home/davep/.rc/func.completion:41: parse error near `('
# dp_source_rc(): error source rcf>/home/davep/.rc/func.completion<
# nohashlistall         off
# But I need the emulate down there (A)

# davep specific code -------------8><------------------
source script-x
emulate bash			# (A).  Needs must be after script-x
set -u
progname="$(basename $0)"
source eexec
if vsetp "${eexec_program-}"    # Did the caller provide a program?
then
    EEXEC_SHIFT=:
else
    eexec_program=$(EExec_parse "$@")
    EEXEC_SHIFT=shift
fi

#
# I'm seeing this:
# (zsh) 2855> optgrep -v hashlistall
# /home/davep/bin/optgrep:30: command not found: EExecVerbose
# nohashlistall         off

#
# By default in bash, when something (eexec, in this case) is sourced, all of
# the functions are known to the sourcer.  Not so in zsh (at least with how
# I've [mis]set it up.  So we emulate bash where we need it.  Then back to
# zsh.
# However, the problem should've already happened since the source has
# already happened by now, so the functions are defined the zsh way.  Why are
# we OK when we use them in bash mode?  Seems like zsh would need to keep
# extra meta-data around.
#emulate bash
for op in $eexec_program
do
    $op
    ${EEXEC_SHIFT}
done
EExec_verbose_msg $(echo_id eexec_program)
unset eexec_program
#export eexec_program
# Or export eexec_program to propagate eexec info to a called program.
# export eexec_program

# davep specific code -------------8><------------------

#mutually exclusive with real EExec# EExec=
#mutually exclusive with real EExec# no_exec_p=
#mutually exclusive with real EExec# Non_EExecer()
#mutually exclusive with real EExec# {
#mutually exclusive with real EExec#     echo "{-} $@" 1>&2
#mutually exclusive with real EExec# }

#mutually exclusive with real EExec# Verbose_EExecer()
#mutually exclusive with real EExec# {
#mutually exclusive with real EExec#     echo "{+} $@"
#mutually exclusive with real EExec#     "$@"
#mutually exclusive with real EExec# }

trap_exit_msg=

# Useful traps
on_exit()
{
    local rc="$?"
    local signum="${1-}"; shift

    echo "on_exit: rc: $rc; ${trap_exit_msg}"
}
# trap 'on_exit' 0

on_error()
{
    local rc="${1-}"; shift

    echo "on_exit: rc: $rc; ${trap_exit_msg}"
    trap '' 0
}
# trap 'on_error' ERR

sig_exit ()
{
    {
        local sig_num=$1; shift
        echo
        echo "sig_exit, sig_num: $sig_num"
        exit 1
    } 1>&2
}

# for sig in 2 3 4 5 6 7 8 15
# do
#     trap "sig_exit $sig" $sig
# done

display_stderr()
{
    echo 1>&2 "$progname: $@"
}

status_msg()
{
    display_stderr "$@"
}

fatal_error()
{
    local error="${1}"
    shift
    display_stderr "$@"
    exit "${error}"
}

Usage_error()
{
    fatal_error 1 "$@"
}

#
# template end.
########################################################################

# @todo XXX Genericize for BASH and ZSH.
# @todo XXX # Must be in the same shell instance to guarantee up-to-date
#  results.  Turn this into a shell function.

: ${GREPPER=egrep}
: ${fix__=true}
: ${fix_all_=false}
: ${fix_no=false}
: ${no_no=false}		# @todo XXX Write me.
: ${option_query=set -o}

greppit()
{
    local option_name="${1}"; shift
    local massaged=$(echo "${option_name}" | tr '[:upper:]' '[:lower:]' \
			 | sed -r 's/[_-]//gp')
    [ -z "${massaged}" ] && {
	echo "$progname: Something went wrong with massaging >${option_name}<"
	echo "  into canonical form.  Massaged string is empty."
	exit 1
    } 1>&2
    # Needs the eval because of the way zsh does string parsing.  It should
    # be split when being run by the shell.  Since I can always use quotes if
    # I want it to be one word, and there's no easy way that I know of
    # (i.e. nothing like single quotes) only eval which, for some reason, I
    # like to avoid.
    eval ${option_query} | "${GREPPER}" "${massaged}"
}

for o in "$@"
do
    # Check this file's history to see a foolish attempt to underscores so
    # that NO_THIS matches nothis and N_o_th_is.
    # Turns out that "set -o" always prints options in lower case sans '_'.
    # EExec_verbose_echo_id GREPPER
    # EExec_verbose_echo_id o
    greppit "${o}"
done
