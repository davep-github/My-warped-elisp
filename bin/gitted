#!/bin/bash

source script-x
set -u

# @todo XXX Make `git_fun' an array and to allow combinations of functionality,
# like adding the printing of .git along with file or !quiet.

progname=$(basename $0)

DOT_NOT_GIT=12

gitted_p()
{
    # Make sure . is gitted.
    git ls-files --error-unmatch "."
    if ! git ls-files --error-unmatch "." >/dev/null 2>&1
    then
	echo 1>&2 "cwd >${PWD}< is not part of a git repo."
	retrc "${DOT_NOT_GIT}"			# rc
    else
	local file="$1"
	git ls-files --error-unmatch "${file}" # rc from git (duh).
    fi
}

gitted_p_quiet()
{
    local file="$1"
    gitted_p "$file" > /dev/null 2>&1
}

gitted_p_debug()
{
    local file="$1"
    gitted_p "$file"
}

gitted_p_verbose()
{
    local file="$1"
    local git_msg
    git_msg=$(gitted_p "$file" 2>&1)
    local rc="$?"
    if ((rc == 0))
    then
        echo "++ $file is under git's dominion."
        return 0
    elif ((rc == 1))
    then
        echo "-- $file is not under git's dominion: $rc."
        return 1
    else
	{
	    ((rc == DOT_NOT_GIT)) && {
		echo "${git_msg}"
		return "${rc}"
	    }
	    echo "Something failed, and I know not what, but the rc is: ${rc}."
	    [ -n "$git_msg" ] && {
		echo "and git said>${git_msg}<"
	    }
	} 1>&2
    fi
    # WTF?
    return 2
}

gitted_p_file()
{
    local file="$1"; shift
    if gitted_p "$file" > /dev/null 2>&1
    then
        echo "$file"
    fi
}
gitted_p_dotgit()
{
    local file="$1"; shift
    if gitted_p "$file" > /dev/null 2>&1
    then
	{
	    echo "$progname: dotgit: $(realpath $(git-dotgit))"
	} 2>/dev/null
    else
        echo "$file"
    fi
}

: ${git_fun="gitted_p_quiet"}
: ${quiet_p=}
: ${show_dot_git_p=false}

# Parse command line.
# std_options has some "useful" options.
# Set to "" or "-" to get nothing.  It's an error to call dp-getopt+.sh with
# std_options unset.
std_options=""
DPGOP_Usage_args_info=" file..."
DPGOP_Usage_synopsis="
Display whether or not each file is under git domination.
-f : file    -- Output the file name if dominated. Else nothing.
-d : debug   -- See raw results from git command, it's exit status.
-q : quiet   -- No output, just exit with status.

Default is to show a message showing domination status.
Exit:
  0: File is dominated
  1: File is Free, not dominated, but not necessarily indomitable.
  ?: WTF?
"

# The real meat...
option_str="fdqVgd"
declare -a long_options
#Each element is a long option name sans '--'
long_options=(
    "vv" "vv" "verbose"		# --v, --vv since EExec usurps -v
    "quiet"			# -a, anti vv
    "debug"			# -d
    "file"			# -f
    "vvv" "dot-git"		# -d|-g
)

source dp-getopt+.sh            # Runs when sourced.

# Loop over your options.
$DP_SCRIPT_X_DEBUG_ONLY_ECHO_STDOUT "1:@>$@<"
for i in "$@"; do
    case "$1" in
        -f|--file) git_fun="gitted_p_file";;
        -d|--debug) git_fun="gitted_p_debug";;
        -q|--quiet) git_fun="gitted_p_quiet"
		    quiet_p=t;;
	-V|--vv|--verbose) git_fun="gitted_p_verbose"
			   quiet_p=;;
	-d|-g|--vvv|--dot-git) git_fun="gitted_p_dotgit";;
        --) shift; break;;
    esac
    shift
done

at_least_one_fail=0
for f in "$@"
do
    [ -e "${f}" ]
    rc="$?"
    [ -e "$f" ] || {
	echo "FOAD!"
	at_least_one_fail=1
	## I'd be nice to know if I'm called from the command line and be
	## verbose by default.
	[[ -z "${quiet_p}" ]] && {
	    # print the fail prefix for bad programs using this.
            echo "-- $progname: $f does not exist."
	} 1>&2
	echo "show_dot_git_p>${show_dot_git_p}<"
	continue
    }
    "$git_fun" "$f" || at_least_one_fail=1
done

exit "${at_least_one_fail}"
