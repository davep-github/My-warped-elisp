#!/bin/bash

source script-x
set -u

progname=$(basename $0)

DOT_NOT_GIT=12

gitted_p()
{
    # Make sure . is gitted.
    git ls-files --error-unmatch "."
    if ! git ls-files --error-unmatch "." >/dev/null 2>&1
    then
	echo 1>&2 "cwd >${PWD}< is not part of a git repo."
	retrc "${DOT_NOT_GIT}"			# rc
    else
	local file="$1"
	git ls-files --error-unmatch "${file}" # rc from git (duh).
    fi
}

gitted_p_quiet()
{
    local file="$1"
    gitted_p "$file" > /dev/null 2>&1
}

gitted_p_debug()
{
    local file="$1"
    gitted_p "$file"
}

gitted_p_normal()
{
    local file="$1"
    local git_msg
    git_msg=$(gitted_p "$file" 2>&1)
    local rc="$?"
    if ((rc == 0))
    then
        echo "++ $file is under git's dominion."
        return 0
    elif ((rc == 1))
    then
        echo "-- $file is not under git's dominion: $rc."
        return 1
    else
	{
	    ((rc == DOT_NOT_GIT)) && {
		echo "${git_msg}"
		return "${rc}"
	    }
	    echo "Something failed, and I know not what, but the rc is: ${rc}."
	    [ -n "$git_msg" ] && {
		echo "and git said>${git_msg}<"
	    }
	} 1>&2
    fi
    # WTF?
    return 2
}

gitted_p_file()
{
    local file="$1"; shift
    if gitted_p "$file" > /dev/null 2>&1
    then
        echo "$file"
    fi
}

: ${git_fun="gitted_p_normal"}
: ${quiet_p=}


# Parse command line.
# std_options has some "useful" options.
# Set to "" or "-" to get nothing.  It's an error to call dp-getopt+.sh with
# std_options unset.
std_options=""
DPGOP_Usage_args_info=" file..."
DPGOP_Usage_synopsis="
Display whether or not each file is under git domination.
-f : file    -- Output the file name if dominated. Else nothing.
-d : debug   -- See raw results from git command, it's exit status.
-q : quiet   -- No output, just exit with status.

Default is to show a message showing domination status.
Exit:
  0: File is dominated
  1: File is Free, not dominated, but not necessarily indomitable.
  ?: WTF?
"

# The real meat...
option_str="fdq"
source dp-getopt+.sh            # Runs when sourced.
# Loop over your options.
$DP_SCRIPT_X_DEBUG_ONLY_ECHO_STDOUT "1:@>$@<"
for i in "$@"; do
    case "$1" in
        -f) git_fun="gitted_p_file";;
        -d) git_fun="gitted_p_debug";;
        -q) git_fun="gitted_p_quiet"
            quiet_p=t;;
        --) shift; break;;
    esac
    shift
done

at_least_one_fail=0
for f in "$@"
do
  [ -e "$f" ] || {
      at_least_one_fail=1
      [ -z "${quiet_p}" ] && {
	  # print the fail prefix for bad programs using this.
          echo "-- $progname: $f does not exist."
      } 1>&2
      continue
  }
  "$git_fun" "$f" || at_least_one_fail=1
done

exit "${at_least_one_fail}"
