#!/bin/sh
source script-x
progname="$(basename $0)"
source eexec
set -u

eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program


# Use my teeker program which saves stdin into a file like tee, but simply
# ticks off chars to stdout using tikker. Makes for a lot less output but
# gives feedback that something is happening.
teekerer()
{
    EExec -y teeker $teeker_opts "$@"
}

teekerer_sample()
{
    EExec -y teeker -s -i $teeker_interval "$@"
}

teeer()
{
    EExecDashN_p && {
        set -- /dev/null
    }
    EExec -y tee "$@"
}

: ${save_args_p=t}
: ${p4_sync_dash_n=}
: ${p4_sync_dash_f=}
: ${send_mail_on_completion_p:=t}
: ${tee_append_opt=}

tee_func=teekerer_sample
teeker_opts=
teeker_interval=100
std_options=""
option_str="nvqtsk:i:fN1o"
long_options=("teeker-opts:" "tee-func:" "teeker-interval:"
    "p4-sync-dash-n"
    "sample" "tee" "teeker"
    "mail" "notify-on-completion" "email-on-completion" "yopp" "send-mail"
    "no-log-file"
    "no-save-args")

source dp-getopt+.sh
for i in "$@"
do
  # do. e.g.  shift; $OPTION_ARG=$1;; to process options with arguments.
  case $1 in
      -n) EXEC=echo; EExecDashN; tee_func=teeer;; # Don't actually execute stuff
      -v) VERBOSE="echo $progname: "; EExecVerbose;;
      -q) VERBOSE=":"; EExecQuiet;;
      -t|--tee) tee_func=teeer;;
      -k|--teeker-opts) shift; teeker_opts="$1";;
      -i|--teeker-interval) shift; teeker_interval="$1";;
      -f) p4_sync_dash_f="-f";;
      -N|--p4-sync-dash-n) p4_sync_dash_n=-n;;
      -1|-o|--no-log-file) kwa_log_file=/dev/null; 
                           tee_func=teeer;; # stdout is fd[1] and stdOut.
      --no-save-args) save_args_p=;;
      --tee-func) shift; tee_func="$1";;
      --sample) tee_func=teekerer_sample;;
      --teeker) tee_func=teekerer;;
      --mail|--notify-on-completion|--email-on-completion|--yopp|--send-mail) 
                  send_mail_on_completion_p=t;;
      --) shift ; break ;;
      *) 
      echo 1>&2 "Unsupported option>$1<";
      Usage
      exit 1 ;;
    esac
    shift
done

: ${sandbox_root:=$(dp4-get-root)}
: ${kwa_log_root:=${sandbox_root}/${progname}}
: ${kwa_log_base:=${progname}}
: ${kwa_log_dir:=${kwa_log_root}/${kwa_log_base}-$(dp-std-timestamp)}
: ${kwa_log_file:=${kwa_log_dir}/${progname}.out}
EExec -y mkdir -p "${kwa_log_dir}"
EExec -y cd "${sandbox_root}"
EExec_verbose_msg "Sync'ing in >$(pwd)<"

EExec_verbose_msg p4 command: p4 sync ${p4_sync_dash_n} ${p4_sync_dash_f} "$@" 

echo "log dir>${kwa_log_dir}<"
{
    # print log name before and after in case it is a long sync.
    [ -n "$save_args_p" ] && {
        save_args_file="${kwa_log_dir}/dp4-sync.args"
        echo_id save_args_file
        echo "p4 sync args:
$@" >| "${save_args_file}"
    }
    EExec p4 sync ${p4_sync_dash_n} ${p4_sync_dash_f} "$@" 
} 2>&1 | EExec -y $tee_func "${kwa_log_file}"
{
    echo
    # Let me know if anything needs merging. -n --> just show problems.
    files_to_resolve=$(p4 resolve -n) || {
        echo "$progname: p4 resolve failed."
        exit 1
    } 1>&2

    # p4 resolve's message about no files to resolve goes to stderr.
    vsetp "${files_to_resolve}" && {
        echo "******* There are files to resolve *******"
        # $() converts newlines to spaces.
        for ftr in ${files_to_resolve}
        do
          echo "${ftr}"
        done
        echo "These files must be resolved by hand."
        echo "*******"
    }

} 2>&1 | EExec -y tee -a "${kwa_log_file}"

echo "log dir>${kwa_log_dir}<"

EExecDashN_p && {
    echo "EExecDashN_p is true, deleting log dir."
    EExec -y rm -rf "${kwa_log_dir}"
} 1>&2

EExec dp4-sync-post-processor

vsetp "${send_mail_on_completion_p-}" && ! EExecDashN_p && {
    mail -s "$progname is done" "${USER}" < /dev/null >/dev/null 2>&1
}


exit
