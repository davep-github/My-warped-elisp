#!/usr/bin/env python

import os, sys, string, types, re
import gzip, argparse
import dp_utils, ticker_lib

# Regular variable names are strings. So we'll use a non-string for some
# special, internal codes. This `var' holds the constructor of the chosen
# Ticker*_t
CTOR = ("special var", "constructor")

def identity(x, *args, **kw_args):
    if args:
	return [x] + args
    return x

def true(*args, **kwargs):
    return True

def false(*args, **kwargs):
    return False

def eval_with_units(num, allow_fractions_p=False):
    if (num == "-1"):
        return False                    # No limit
    return dp_utils.numWithUnits(num, allow_fractions_p=allow_fractions_p)

def eval_with_units_fractions_ok(num):
    return eval_with_units(num, allow_fractions_p=True)

def add_to_dict_action(actor, dictionary, parser, namespace, values,
                       option_string=None):
    print 'dest: %s, ns: %r, values: %r, ostr: %r' % (actor.dest,
                                                      namespace,
                                                      values,
                                                      option_string)
    dictionary[actor.dest] = values
    
Ctor_arg_dict = {}
class Ctor_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace,
                           values, option_string)

class Ctor_arg_action_true(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, True,
                           option_string=None)
    

App_arg_dict = {}
class App_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           values, option_string)
        


if __name__ == "__main__":
    import optparse
    def_tick_interval = 100
    ostream = sys.stdout
    def_pipe_stream = sys.stdout
    pipe_stream = def_pipe_stream
    grand_total_p = True
    sample_lines_tick_p = False
    sample_lines_tick_prefix = "th-line>"
    no_clobber_p = False
    openMode = 'w'
    outputStreams = []
    compress_p = False
    file_suffix = ""
    U_extension = ".log"
    grep_patterns = []
    grepped_lines = []
    line_number = 0
    ctor_keywords = {}
    ctor_keywords["max_output_units_before_newline"] = 80 * 100
    var_dict = {CTOR: ticker_lib.Ticker_t, "tick_interval": 1}
    append_p = False
    ## Each -Z adds one, and we want a single -Z to yield max compression.

    # tick_interval, increment=1, init_string="counting: ", comma=", ",
    # init_count=0, tick_char

    oparser = argparse.ArgumentParser()

    oparser.add_argument("-i", "--tick-interval",
                         dest="tick_interval", type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Set ticker's tick interval.")
    oparser.add_argument("-T", "--show-twiddles",
                         dest="show_twiddles_p",
                         default=False, action='store_true',
                         help="Show list of available twiddles.")
    oparser.add_argument("-l", "-s", "--sample-lines",
                         dest="sample_lines_tick_p",
                         default=False, action='store_true',
                         help="Tick with input line samples.")
    oparser.add_argument("-L", "-S", "--sample-lines-prefix",
                         dest="sample_lines_tick_prefix", action="store",
                         default="th-line>",
                         help="Prefix for sampled lines.")
    oparser.add_argument("-A", "--no-clobber",
                         dest="no_clobber_p", default=False,
                         action='store_true',
                         help="Don't clobber existing files. Exit.")
    oparser.add_argument("-Z", "--compression-level",
                         dest="compression_level", type=int,
                         help="Compression level.")
    oparser.add_argument("-u", "--timestamp",
                         dest="add_timestamp_p", default=False,
                         action='store_true',
                         help="Add uniquifying timestamp to output file name.")
    oparser.add_argument("-E", "--extension",
                         dest="U_extension", default=".log",
                         action="store",
                         help="Addition output file extension. Added last, after timestamp [if present].")
    oparser.add_argument("-U", "--show-units",
                         dest="show_tick_units_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Print units [chars, lines] with output.")
    oparser.add_argument("-I", "--increment",
                         dest="increment", type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Increment")
##     oparser.add_argument("-m", "--max-output-line-len",
##                          dest="max_output_units_before_newline", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback_eval_with_units,
##                          help="Maximum ticks per line")
##     oparser.add_argument("-M", "--max-output",
##                          dest="max_output_units_before_exit", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback_eval_with_units,
##                          help="Maximum ticks before exiting.")
##     oparser.add_argument("-P", "--prefix", "--initial-string",
##                          dest="init_string", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback,
##                          help="Initial prefix string.")
##     oparser.add_argument("-C", "--comma", "--count-separator", "--separator",
##                          dest="comma", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback)
##     oparser.add_argument("-z", "--initial-count",
##                          dest="init_count", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback_eval_with_units,
##                          help="Initial count [number of units]")
##     oparser.add_argument("-c", "--tick-char",
##                          dest="tick_char", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback_char,
##                          help="""Tick character. Mutually exclusive with twiddle.
## Implies Char_ticker_t""")
##     oparser.add_argument("-d", "--dots",
##                          action="callback",
##                          callback=constructor_arg_callback_dots,
##                          dest="tick_char",
##                          help="Use dots for tick char. Implies Char_ticker_t.")
##     oparser.add_argument("-.", "--char-dots",
##                          dest="tick_char",
##                          action="callback",
##                          callback=constructor_arg_callback_dots_and_char_wise,
##                          help="Char_ticker_t, count chars, tick with '.'.")
##     oparser.add_argument("-D", "--DOTS",
##                          dest="tick_char", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback_DOTS,
##                          help="Like --dots + tick interval.")
##     oparser.add_argument("-t", "--twiddle",
##                          dest="twiddle_chars",
##                          type="int",
##                          action="callback",
##                          callback=constructor_arg_callback_twiddle,
##                          help="Set twiddle chars. Implies Twiddle_ticker_t")
##     oparser.add_argument("-G", "--print-grand-total",
##                          dest="grand_total_p",
##                          action="callback",
##                          callback=constructor_arg_callback_true,
##                          help="Print grand total at end.")
##     oparser.add_argument("-k", "--char-wise",
##                          dest="char_wise_p",
##                          action="callback",
##                          callback=teeker_arg_callback_true,
##                          help="Count chars vs lines [the default].")
##     oparser.add_argument("-K", "--char-wise-char", "--char-tick-char",
##                          dest="tick_char", type="string",
##                          action="callback",
##                          callback=constructor_arg_callback_char_and_char_wise,
##                          help="Count chars vs lines [the default] and set tick char.")
##     oparser.add_argument("-p", "-e", "--pipe-mode", "--output-to-stderr",
##                          "--tick-to-stderr",
##                          dest="pipe_mode_p",
##                          default=False, action="store_true",
##                          help="Send ticks to stderr and input to stdout.")

##     # tee(1) compatibility.
##     oparser.add_argument("-a", "--append",
##                          dest="append_p",
##                          action="store_true",
##                          default=False,
##                          help="Append data to output file(s).")

    args = oparser.parse_args()

    print "args:", args
    print "Ctor_arg_dict:", Ctor_arg_dict

    sys.exit(99)
#    print "oparser.ticker_ctor_kwargs>%s<" % (oparser.ticker_ctor_kwargs,)

    print "compression:", options.compression_level
    compress_p = options.compression_level >= 0
    print "compress_p:", compress_p
#    print "options>%s<" % (options,)
#    print "dir(options)>%s<" % (dir(options),)
#    for key, value in options.items():
#        print "%s>%s<" % (key, value)
#    for o in oparser.option_list:
#        print "o>%s<" % (o,)
    for key, value in ctor_keywords.items():
        print "ctor_kw: %s>%s<" % (key, value)
    

    if options.show_twiddles_p:
        ticker_lib.Twiddle_twiddles()
        sys.exit(0)
    if options.append_p:
        openMode = "a"

    for a in args:
        a = a + file_suffix
        if no_clobber_p:
            if os.path.exists(a):
                print >>sys.stderr, "File [%s] exists: not clobbering" % (a,)
                sys.exit(1)
        if compress_p:
            # zipfile.ZipFile(file[, mode[, compression[, allowZip64]]])
            print "compression:", options.compression_level
            fobj = gzip.open(a + ".gz", openMode, options.compression_level)
        else:
            fobj = open(a, openMode)

        # I *love* duck typing.
        outputStreams.append(fobj)


    #!<@todo Check for twiddle ticker request and handle that.
    #print "ctor_keywords:", ctor_keywords
    # pipe mode: Ticks go to stderr and lines go to stdout.
    pipe_mode_p, char_wise_p = (var_dict.get("pipe_mode_p", False),
                                var_dict.get("char_wise_p", False))

    #if ctor_keywords.get("twiddle_chars", False) != False:
    #    ctor_keywords["init_string"] = ""
    #
    if ctor_keywords.get("init_string", False) == False:
        if char_wise_p:
            ctor_keywords["init_string"] = "Counting chars: "
            ctor_keywords["unit_name"] = 'char'
        else:
            ctor_keywords["init_string"] = "Counting lines: "
            ctor_keywords["unit_name"] = 'line'

    if pipe_mode_p:
        ctor_keywords["ostream"] = sys.stderr
    else:
        ctor_keywords["ostream"] = ostream

    if sample_lines_tick_p:
        ctor_keywords["init_string"] = "Sampling every %sth line\n" % \
                                       (options.ticker_ctor_kwargs["tick_interval"])
        ctor_keywords["unit_name"] = 'line'
        ctor_keywords["comma"] = ""     # Line will end with newline.

    print "max_output_units_before_newline", ctor_keywords["max_output_units_before_newline"]
    ticker = var_dict[CTOR](var_dict["tick_interval"], **ctor_keywords)
    if pipe_mode_p:
        outputStreams.append(pipe_stream)
        ostream.write("\n")
    while True:
	l = sys.stdin.readline()
	if not l:
            if grepped_lines:
                print "\n================="
                print "Num matching lines:", len(grepped_lines)
                tlos = outputStreams.append(sys.stdout)
                for lt in  grepped_lines:
                    for o in outputStreams:
                        o.write("Matching line: %s: %s\n" % (lt[1],
                                                             lt[0][:-1]))
                print "================="
            ticker.fini()
            break
        line_number += 1
        for o in outputStreams:
            o.write(l)
        for regexp in grep_patterns:
            if regexp.search(l):
                grepped_lines.append((l, line_number))
                break
        if char_wise_p:
            # Iterate for each char in the line.
            for c in l:
                if sample_lines_tick_p:
                    tick = sample_lines_tick_prefix + c
                else:
                    tick = None
                ticker(tick=tick)
        else:
            if sample_lines_tick_p:
                # @todo XXX allow a format to be used (dictionary type)
                tick = "%8d%s" % (ticker.counter, sample_lines_tick_prefix + l)
            else:
                tick = None
            ticker(tick=tick)
    print
