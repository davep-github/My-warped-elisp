#!/usr/bin/env python

import os, sys, string, types, re
import gzip, argparse
import dp_utils, ticker_lib

# Regular variable names are strings. So we'll use a non-string for some
# special, internal codes. This `var' holds the constructor of the chosen
# Ticker*_t
class CTOR_t:
    def __init__(self):
        self.info = "I am the index of the constructor."

CTOR = CTOR_t()

parse_debug = 0

def identity(x, *args, **kw_args):
    if args:
	return [x] + args
    return x

def true(*args, **kwargs):
    return True

def false(*args, **kwargs):
    return False

def eval_with_units(num, allow_fractions_p=False):
    if (num == "-1"):
        return False                    # No limit
    return dp_utils.numWithUnits(num, allow_fractions_p=allow_fractions_p)

def eval_with_units_fractions_ok(num):
    return eval_with_units(num, allow_fractions_p=True)

def add_to_dict_action(actor, dictionary, parser, namespace, values,
                       option_string=None, dest=None, ext_dict=False):
    if parse_debug:
        print 'dest: %s, ns: %r, values: %r, ostr: %r' % (actor.dest,
                                                          namespace,
                                                          values,
                                                          option_string)
    dest = dest or actor.dest
    if ext_dict:
        dictionary.update(ext_dict)
    else:
        dictionary[dest] = values
    if type(dest) == types.StringType:
        setattr(namespace, dest, values)

App_arg_dict = {CTOR: ticker_lib.Ticker_t}

Ctor_arg_dict = {}

class Ctor_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None,
                 dest=None, ext_dict=False):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace,
                           values, option_string, dest=dest,
                           ext_dict=ext_dict)

class Ctor_arg_action_true(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, True,
                           option_string=None)

class Ctor_arg_action_false(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, False,
                           option_string=None)

class Ctor_arg_action_char(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, values,
                           option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)

class Ctor_arg_action_dots(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, ".",
                                      option_string=option_string)
    
class Ctor_arg_action_char_and_char_wise(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, values,
                                     option_string=option_string)
        add_to_dict_action(self, App_arg_dict, parser, namespace, True,
                           dest="char_wise_p")

class Ctor_arg_action_dots_and_char_wise(Ctor_arg_action_char_and_char_wise):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char_and_char_wise.__call__(self,
                                                    parser, namespace, ".",
                                                    option_string=option_string)

#
# Set tick interval to value, set tick_char to "."
class App_arg_action_DOTS(argparse.Action):
    # set interval
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)
        setattr(namespace, self.dest, values)
        # Set tick char = '.'
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, ".",
                           dest="tick_char")

Convenience_opts = (("U_extension", ".log"), ("add_timestamp_p", True))

def set_convenience_opts(namespace):
    for name, val in Convenience_opts:
        setattr(namespace, name, val)

def show_convenience_opts():
    ret = ""
    l = len(Convenience_opts)
    if l > 1:
        sep = ", "
    for name, val in Convenience_opts:
        if l == 1:
            sep = ""
        ret += "%s: %s" % (name, val) + sep
        l -= 1
    return ret

class App_action_log_file_convenience(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "output_files_required_p", True)

class App_action_log_file_convenience_sampled(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "sample_lines_tick_p", True)
        setattr(namespace, "output_files_required_p", True)

class Ctor_arg_action_twiddle(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action.__call__(self, parser, namespace, values,
                                 option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Twiddle_ticker_t,
                           option_string, CTOR)


if __name__ == "__main__":
    import optparse
    def_tick_interval = 100
    ostream = sys.stdout
    def_pipe_stream = sys.stdout
    pipe_stream = def_pipe_stream
    openMode = 'w'
    outputStreams = []
    file_suffix = ""
    grepped_lines = []
    line_number = 0
    Ctor_arg_dict["max_output_units_before_newline"] = 80 * 100
    append_p = False
    default_compression_level = 5
    ## Each -Z adds one, and we want a single -Z to yield max compression.

    # tick_interval, increment=1, init_string="counting: ", comma=", ",
    # init_count=0, tick_char

    oparser = argparse.ArgumentParser()

    oparser.add_argument("--debug",
                         dest="debug", type=int, default=0)
    oparser.add_argument("-i", "--tick-interval",
                         dest="tick_interval", type=eval_with_units,
                         default=def_tick_interval,
                         help="Set ticker's tick interval.")
    oparser.add_argument("-T", "--show-twiddles",
                         dest="show_twiddles_p", default=False,
                         action="store_true",
                         help="Show list of available twiddles.")
    oparser.add_argument("-s", "--sample-lines",
                         dest="sample_lines_tick_p", default=False,
                         action="store_true",
                         help="Tick with input line samples.")
    oparser.add_argument("-S", "--sample-lines-prefix",
                         dest="sample_lines_tick_prefix", default="th-line>",
                         action=Ctor_arg_action,
                         help="Prefix for sampled lines.")
    oparser.add_argument("-A", "--no-clobber",
                         dest="no_clobber_p", default=False,
                         action="store_true",
                         help="Don't clobber existing files. Exit.")
    oparser.add_argument("-Z", "--compression-level",
                         dest="compression_level", type=int,
                         help="Compression level.")
    oparser.add_argument("-z", "--compress",
                         dest="compression_level",
                         const=default_compression_level,
                         action="store_const",
                         help="Set compression level to %s." % (default_compression_level))
    oparser.add_argument("-u", "--timestamp-log-files",
                         dest="add_timestamp_p", default=False,
                         action="store_true",
                         help="Add uniquifying timestamp to output file name.")
    oparser.add_argument("-E", "--extension",
                         dest="U_extension", default="",
                         type=str,
                         help="Addition output file extension. Added last, after timestamp [if present].")
    oparser.add_argument("-l", "--log-file",
                         dest="U_extension", const=".log",
                         action="store_const",
                         help="Add .log suffix.")
    oparser.add_argument("--log",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         action=App_action_log_file_convenience,
                         help=("Save to log file with useful defaults:\n" +
                               show_convenience_opts()))
    oparser.add_argument("--slog",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         action=App_action_log_file_convenience_sampled,
                         help="As --log plus sampled ticking.")
    oparser.add_argument("-U", "--show-units",
                         dest="show_tick_units_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Print units [chars, lines] with output.")
    oparser.add_argument("--timestamp",
                         dest="timestamp_p", default=False,
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Add a timestamp to ticks. Best with sampled output.")
    oparser.add_argument("-I", "--increment",
                         dest="increment", type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Increment")
    oparser.add_argument("-m", "--max-output-line-len",
                         dest="max_output_units_before_newline",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks per line")
    oparser.add_argument("-M", "--max-output",
                         dest="max_output_units_before_exit",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks before exiting.")
    oparser.add_argument("-P", "--prefix", "--initial-string",
                         dest="init_string",
                         action=Ctor_arg_action,
                         help="Initial prefix string.")
    oparser.add_argument("-C", "--comma", "--count-separator", "--separator",
                         dest="comma",
                         action=Ctor_arg_action,
                         help="Separator character between ticks.")
    oparser.add_argument("--initial-count",
                         dest="init_count",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Initial count [number of units]")
    oparser.add_argument("-c", "--tick-char",
                         dest="tick_char", default=None,
                         action=Ctor_arg_action,
                         help="""Tick character. Mutually exclusive with twiddle.
Implies Char_ticker_t""")
    oparser.add_argument("-d", "--dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots,
                         help="Use dots for tick char. Implies Char_ticker_t.")
    oparser.add_argument("-.", "--char-dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots_and_char_wise,
                         help="Char_ticker_t, count chars, tick with '.'.")
    oparser.add_argument("-D", "--DOTS",
                         dest="tick_interval",
                         type=eval_with_units,
                         action=App_arg_action_DOTS,
                         help="Like --dots + tick interval.")
    oparser.add_argument("-t", "--twiddle",
                         dest="twiddle_chars", type=int,
                         action=Ctor_arg_action_twiddle,
                         help="Set twiddle chars. Implies Twiddle_ticker_t")
    oparser.add_argument("-G", "--print-grand-total",
                         dest="grand_total_p", default=True,
                         nargs=0,
                         action=Ctor_arg_action_false,
                         help="Print grand total at end.")
    oparser.add_argument("-k", "--char-wise",
                         dest="char_wise_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Count chars vs lines [the default].")
    oparser.add_argument("-K", "--char-wise-char", "--char-tick-char",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_char_and_char_wise,
                         help="Count chars vs lines [the default] and set tick char.")
    oparser.add_argument("-p", "-e", "--pipe-mode", "--output-to-stderr",
                         "--tick-to-stderr",
                         dest="pipe_mode_p", default=False,
                         action="store_true",
                         help="Send ticks to stderr and input to stdout.")
    oparser.add_argument("-g", "--grep", "--regexp",
                         dest="regexp_patterns",
                         action="append", default=[],
                         help='Grep for these patterns and treat "specially".')
    oparser.add_argument("--highlight-grep", "--highlight-matches",
                         dest="highlight_grep_matches_p", default=False,
                         action="store_true",
                         help="Show matches as they occur.")
    oparser.add_argument("--no-grep-summary", "--no-match-summary",
                         dest="match_summary_p", default=True,
                         action="store_false",
                         help="Don't show all grep matches at end of run.")
    
    # tee(1) compatibility.
    oparser.add_argument("-a", "--append",
                         dest="append_p", default=False,
                         action="store_true",
                         help="Append data to output file(s).")

    oparser.add_argument("output_files", nargs="*")

    app_args = oparser.parse_args()

    if app_args.debug:
        print "app_args:", app_args
        print "Ctor_arg_dict:", Ctor_arg_dict
        print "App_arg_dict:", App_arg_dict

    ticker_constructor = App_arg_dict.pop(CTOR)

    compress_p = app_args.compression_level >= 0

    if app_args.show_twiddles_p:
        ticker_lib.Twiddle_twiddles()
        sys.exit(0)

    if app_args.append_p:
        openMode = "a"

    if app_args.add_timestamp_p:
        file_suffix = "." + dp_utils.bq("dp-std-timestamp")
    file_suffix += app_args.U_extension

    if app_args.debug:
        print "app_args.output_files>%s<" % (app_args.output_files,)
    if len(app_args.output_files) == 0 and app_args.output_files_required_p:
        print >>sys.stderr, "Log files are required with your other options."
        sys.exit(1)
        
    for a in app_args.output_files:
        if app_args.debug > 1:
            print "a>%s<" % (a,)
        a = a + file_suffix
        if app_args.debug:
            print "output_file>%s<" % (a,)
        if app_args.no_clobber_p:
            if os.path.exists(a):
                print >>sys.stderr, "File [%s] exists: not clobbering" % (a,)
                sys.exit(1)
        if compress_p:
            if app_args.debug:
                print "compression:", app_args.compression_level
            fobj = gzip.open(a + ".gz", openMode, app_args.compression_level)
        else:
            fobj = open(a, openMode)

        # I *love* duck typing.
        outputStreams.append(fobj)


    #!<@todo Check for twiddle ticker request and handle that.
    #print "Ctor_arg_dict:", Ctor_arg_dict
    # pipe mode: Ticks go to stderr and lines go to stdout.
    pipe_mode_p, char_wise_p = (app_args.pipe_mode_p,
                                app_args.char_wise_p)

    #if Ctor_arg_dict.get("twiddle_chars", False) != False:
    #    Ctor_arg_dict["init_string"] = ""
    #
    if Ctor_arg_dict.get("init_string", False) == False:
        if char_wise_p:
            Ctor_arg_dict["init_string"] = "Counting chars: "
            Ctor_arg_dict["unit_name"] = 'char'
        else:
            Ctor_arg_dict["init_string"] = "Counting lines: "
            Ctor_arg_dict["unit_name"] = 'line'

    if pipe_mode_p:
        Ctor_arg_dict["ostream"] = sys.stderr
    else:
        Ctor_arg_dict["ostream"] = ostream

    if app_args.sample_lines_tick_p:
        Ctor_arg_dict["init_string"] = "Sampling every %sth line\n" % (
            app_args.tick_interval)
        Ctor_arg_dict["unit_name"] = 'line'
        Ctor_arg_dict["comma"] = ""     # Line will end with newline.

    if app_args.debug:
        print "final Ctor_arg_dict:", Ctor_arg_dict
    ticker = ticker_constructor(app_args.tick_interval, **Ctor_arg_dict)
    if pipe_mode_p:
        outputStreams.append(pipe_stream)
        ostream.write("\n")

    # Help speed up the loop.
    compiled_regexps = []
    for regexp in app_args.regexp_patterns:
        compiled_regexps.append(re.compile(regexp))
    sample_prefix = app_args.sample_lines_tick_prefix
    while True:
	input_line = sys.stdin.readline()
	if not input_line:
            if app_args.match_summary_p and grepped_lines:
                print "\n================="
                print "Num matching lines:", len(grepped_lines)
                tlos = outputStreams.append(sys.stdout)
                for lt in  grepped_lines:
                    for o in outputStreams:
                        o.write("Matching line: %s: %s\n" % (lt[1],
                                                             lt[0][:-1]))
                print "================="
            ticker.fini()
            break
        line_number += 1
        for o in outputStreams:
            o.write(input_line)
        for regexp in compiled_regexps:
            if regexp.search(input_line):
                grepped_lines.append((input_line, line_number))
                if app_args.highlight_grep_matches_p:
                    # XXX @todo Add ANSI color options?
                    print "line:", line_number, "***", input_line[:-1], "***"
                break
        if char_wise_p:
            # Iterate for each char in the line.
            for c in input_line:
                if app_args.sample_lines_tick_p:
                    tick = sample_prefix + c
                else:
                    tick = None
                ticker(tick=tick)
        else:
            if app_args.sample_lines_tick_p:
                # @todo XXX allow a format to be used (dictionary type)
                tick = "%8d%s" % (ticker.counter,
                                  sample_prefix + input_line)
            else:
                tick = None
            ticker(tick=tick)
    print
