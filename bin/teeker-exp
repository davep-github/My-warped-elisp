#!/usr/bin/env python

import os, sys, string, types, re
import gzip, argparse
import dp_utils, ticker_lib

# Regular variable names are strings. So we'll use a non-string for some
# special, internal codes. This `var' holds the constructor of the chosen
# Ticker*_t
class CTOR_t:
    def __init__(self):
        self.info = "I am the index of the constructor."

CTOR = CTOR_t()

parse_debug = 0

def identity(x, *args, **kw_args):
    if args:
	return [x] + args
    return x

def true(*args, **kwargs):
    return True

def false(*args, **kwargs):
    return False

def eval_with_units(num, allow_fractions_p=False):
    if (num == "-1"):
        return False                    # No limit
    return dp_utils.numWithUnits(num, allow_fractions_p=allow_fractions_p)

def eval_with_units_fractions_ok(num):
    return eval_with_units(num, allow_fractions_p=True)

def add_to_dict_action(actor, dictionary, parser, namespace, values,
                       option_string=None, dest=None, ext_dict=False):
    if parse_debug:
        print 'dest: %s, ns: %r, values: %r, ostr: %r' % (actor.dest,
                                                          namespace,
                                                          values,
                                                          option_string)
    dest = dest or actor.dest
    if ext_dict:
        dictionary.update(ext_dict)
    else:
        dictionary[dest] = values
    if type(dest) == types.StringType:
        setattr(namespace, dest, values)

App_arg_dict = {}
Ctor_arg_dict = {}

class Ctor_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None,
                 dest=None, ext_dict=False):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace,
                           values, option_string, dest=dest,
                           ext_dict=ext_dict)

class Ctor_arg_action_true(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, True,
                           option_string=None)

class Ctor_arg_action_false(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, False,
                           option_string=None)

class App_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None,
                 dest=None, ext_dict=False):
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           values, option_string)

class App_arg_action_true(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, App_arg_dict, parser, namespace, True,
                           option_string=None)

class App_arg_action_false(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, App_arg_dict, parser, namespace, False,
                           option_string=None)

class Ctor_arg_action_char(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, values,
                           option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)

class Ctor_arg_action_dots(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, ".",
                                      option_string=option_string)
    
class Ctor_arg_action_char_and_char_wise(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, values,
                                     option_string=option_string)
        add_to_dict_action(self, App_arg_dict, parser, namespace, True,
                           dest="char_wise_p")

class Ctor_arg_action_dots_and_char_wise(Ctor_arg_action_char_and_char_wise):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char_and_char_wise.__call__(self,
                                                    parser, namespace, ".",
                                                    option_string=option_string)

class App_arg_action_DOTS(App_arg_action):
    # set interval
    def __call__(self, parser, namespace, values, option_string=None):
        App_arg_action.__call__(self, parser, namespace, values,
                                 option_string=None)
    # tick char = '.'
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, ".",
                           dest="tick_char")

class Ctor_arg_action_toggle_bool(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        #         new_count = _ensure_value(namespace, self.dest, 0) + 1
        new_val = not Ctor_arg_dict.get(self.dest, self.default)
        Ctor_arg_action.__call__(self, parser, namespace, new_val,
                                 option_string=option_string)
    

## def constructor_arg_callback_twiddle(option, opt_str, value, parser):
##     parser.teeker_var_dict[CTOR] = ticker_lib.Twiddle_ticker
##     constructor_arg_callback(option, opt_str, eval_twiddle(value), parser)

class Ctor_arg_action_twiddle(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action.__call__(self, parser, namespace, values,
                                 option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Twiddle_ticker_t,
                           option_string, CTOR)


if __name__ == "__main__":
    import optparse
    def_tick_interval = 100
    ostream = sys.stdout
    def_pipe_stream = sys.stdout
    pipe_stream = def_pipe_stream
    sample_lines_tick_p = False
    sample_lines_tick_prefix = "th-line>"
    openMode = 'w'
    outputStreams = []
    file_suffix = ""
    grep_patterns = []
    grepped_lines = []
    line_number = 0
    Ctor_arg_dict["max_output_units_before_newline"] = 80 * 100
    App_arg_dict = {CTOR: ticker_lib.Ticker_t,
                    "tick_interval": def_tick_interval}
    append_p = False
    ## Each -Z adds one, and we want a single -Z to yield max compression.

    # tick_interval, increment=1, init_string="counting: ", comma=", ",
    # init_count=0, tick_char

    oparser = argparse.ArgumentParser()

    oparser.add_argument("--debug",
                         dest="debug", type=int, default=0)
    oparser.add_argument("-i", "--tick-interval",
                         dest="tick_interval", type=eval_with_units,
                         action=App_arg_action,
                         help="Set ticker's tick interval.")
    oparser.add_argument("-T", "--show-twiddles",
                         dest="show_twiddles_p", default=False,
                         nargs=0,
                         action=App_arg_action_true,
                         help="Show list of available twiddles.")
    oparser.add_argument("-l", "-s", "--sample-lines",
                         dest="sample_lines_tick_p", default=False,
                         nargs=0,
                         action=App_arg_action_true,
                         help="Tick with input line samples.")
    oparser.add_argument("-L", "-S", "--sample-lines-prefix",
                         dest="sample_lines_tick_prefix", default="th-line>",
                         action=Ctor_arg_action,
                         help="Prefix for sampled lines.")
    oparser.add_argument("-A", "--no-clobber",
                         dest="no_clobber_p", default=False,
                         action=App_arg_action_true,
                         help="Don't clobber existing files. Exit.")
    oparser.add_argument("-Z", "--compression-level",
                         dest="compression_level", type=int,
                         action=App_arg_action,
                         help="Compression level.")
    oparser.add_argument("-u", "--timestamp",
                         dest="add_timestamp_p", default=False,
                         nargs=0,
                         action=App_arg_action_true,
                         help="Add uniquifying timestamp to output file name.")
    oparser.add_argument("-E", "--extension",
                         dest="U_extension", default="",
                         action=App_arg_action,
                         help="Addition output file extension. Added last, after timestamp [if present].")
    oparser.add_argument("--log-file",
                         dest="U_extension", const=".log",
                         nargs="?",
                         help="Add .log suffix.")
    oparser.add_argument("-U", "--show-units",
                         dest="show_tick_units_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Print units [chars, lines] with output.")
    oparser.add_argument("-I", "--increment",
                         dest="increment", type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Increment")
    oparser.add_argument("-m", "--max-output-line-len",
                         dest="max_output_units_before_newline",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks per line")
    oparser.add_argument("-M", "--max-output",
                         dest="max_output_units_before_exit",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks before exiting.")
    oparser.add_argument("-P", "--prefix", "--initial-string",
                         dest="init_string",
                         action=Ctor_arg_action,
                         help="Initial prefix string.")
    oparser.add_argument("-C", "--comma", "--count-separator", "--separator",
                         dest="comma",
                         action=Ctor_arg_action,
                         help="Separator character between ticks.")
    oparser.add_argument("-z", "--initial-count",
                         dest="init_count",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Initial count [number of units]")
    oparser.add_argument("-c", "--tick-char",
                         dest="tick_char",
                         action=Ctor_arg_action,
                         help="""Tick character. Mutually exclusive with twiddle.
Implies Char_ticker_t""")
    oparser.add_argument("-d", "--dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots,
                         help="Use dots for tick char. Implies Char_ticker_t.")
    oparser.add_argument("-.", "--char-dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots_and_char_wise,
                         help="Char_ticker_t, count chars, tick with '.'.")
    oparser.add_argument("-D", "--DOTS",
                         dest="tick_interval",
                         type=eval_with_units,
                         action=App_arg_action_DOTS,
                         help="Like --dots + tick interval.")
    oparser.add_argument("-t", "--twiddle",
                         dest="twiddle_chars", type=int,
                         action=Ctor_arg_action_twiddle,
                         help="Set twiddle chars. Implies Twiddle_ticker_t")
    oparser.add_argument("-G", "--print-grand-total",
                         dest="grand_total_p", default=True,
                         nargs=0,
                         action=Ctor_arg_action_false,
                         help="Print grand total at end.")
    oparser.add_argument("-k", "--char-wise",
                         dest="char_wise_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Count chars vs lines [the default].")
    oparser.add_argument("-K", "--char-wise-char", "--char-tick-char",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_char_and_char_wise,
                         help="Count chars vs lines [the default] and set tick char.")
    oparser.add_argument("-p", "-e", "--pipe-mode", "--output-to-stderr",
                         "--tick-to-stderr",
                         dest="pipe_mode_p", default=False,
                         nargs=0,
                         action=App_arg_action_true,
                         help="Send ticks to stderr and input to stdout.")

    # tee(1) compatibility.
    oparser.add_argument("-a", "--append",
                         dest="append_p", default=False,
                         nargs=0,
                         action=App_arg_action_true,
                         help="Append data to output file(s).")

    oparser.add_argument("output_files", nargs="*")

    args = oparser.parse_args()

    # Args accumulates all defaults, for both app and ctor args. I prefer the
    # app args to be segregated.
    # In addition, the default values are stored in it. I prefer to have
    # unset args not passed to the c'tor, thus getting the c'tor's default
    # value.
    # Switch back to using normal namespace for app args because it has
    # defaults, which we need in the app because there is no constructor from
    # which we get default values. Do this hack for now. As well as the
    # double set hack in the set code.
    app_args = args # argparse.Namespace(**App_arg_dict)

    if args.debug:
        print "app_args:", app_args
        print "args:", args
        print "Ctor_arg_dict:", Ctor_arg_dict
        print "App_arg_dict:", App_arg_dict

    ticker_constructor = App_arg_dict.pop(CTOR)

    compress_p = app_args.compression_level >= 0

    if app_args.show_twiddles_p:
        ticker_lib.Twiddle_twiddles()
        sys.exit(0)

    if app_args.append_p:
        openMode = "a"

    if app_args.add_timestamp_p:
        file_suffix = "." + dp_utils.bq("dp-std-timestamp")
    file_suffix += app_args.U_extension

    if app_args.debug:
        print "app_args.output_files>%s<" % (app_args.output_files,)
    for a in app_args.output_files:
        if app_args.debug > 1:
            print "a>%s<" % (a,)
        a = a + file_suffix
        if app_args.no_clobber_p:
            if os.path.exists(a):
                print >>sys.stderr, "File [%s] exists: not clobbering" % (a,)
                sys.exit(1)
        if compress_p:
            # zipfile.ZipFile(file[, mode[, compression[, allowZip64]]])
            print "compression:", options.compression_level
            fobj = gzip.open(a + ".gz", openMode, options.compression_level)
        else:
            fobj = open(a, openMode)

        # I *love* duck typing.
        outputStreams.append(fobj)


    #!<@todo Check for twiddle ticker request and handle that.
    #print "Ctor_arg_dict:", Ctor_arg_dict
    # pipe mode: Ticks go to stderr and lines go to stdout.
    pipe_mode_p, char_wise_p = (App_arg_dict.get("pipe_mode_p", False),
                                App_arg_dict.get("char_wise_p", False))

    #if Ctor_arg_dict.get("twiddle_chars", False) != False:
    #    Ctor_arg_dict["init_string"] = ""
    #
    if Ctor_arg_dict.get("init_string", False) == False:
        if char_wise_p:
            Ctor_arg_dict["init_string"] = "Counting chars: "
            Ctor_arg_dict["unit_name"] = 'char'
        else:
            Ctor_arg_dict["init_string"] = "Counting lines: "
            Ctor_arg_dict["unit_name"] = 'line'

    if pipe_mode_p:
        Ctor_arg_dict["ostream"] = sys.stderr
    else:
        Ctor_arg_dict["ostream"] = ostream

    if sample_lines_tick_p:
        Ctor_arg_dict["init_string"] = "Sampling every %sth line\n" % \
                                       (options.ticker_ctor_kwargs["tick_interval"])
        Ctor_arg_dict["unit_name"] = 'line'
        Ctor_arg_dict["comma"] = ""     # Line will end with newline.

    ticker = ticker_constructor(App_arg_dict["tick_interval"],
                                **Ctor_arg_dict)
    if pipe_mode_p:
        outputStreams.append(pipe_stream)
        ostream.write("\n")
    while True:
	l = sys.stdin.readline()
	if not l:
            if grepped_lines:
                print "\n================="
                print "Num matching lines:", len(grepped_lines)
                tlos = outputStreams.append(sys.stdout)
                for lt in  grepped_lines:
                    for o in outputStreams:
                        o.write("Matching line: %s: %s\n" % (lt[1],
                                                             lt[0][:-1]))
                print "================="
            ticker.fini()
            break
        line_number += 1
        for o in outputStreams:
            o.write(l)
        for regexp in grep_patterns:
            if regexp.search(l):
                grepped_lines.append((l, line_number))
                break
        if char_wise_p:
            # Iterate for each char in the line.
            for c in l:
                if sample_lines_tick_p:
                    tick = sample_lines_tick_prefix + c
                else:
                    tick = None
                ticker(tick=tick)
        else:
            if sample_lines_tick_p:
                # @todo XXX allow a format to be used (dictionary type)
                tick = "%8d%s" % (ticker.counter, sample_lines_tick_prefix + l)
            else:
                tick = None
            ticker(tick=tick)
    print
