#!/usr/bin/env python

import os, sys, string, types, re, exceptions
import gzip, argparse
import dp_utils, ticker_lib, dp_io

## @todo XXX Add prefix status string.
## E.g. track number of grep hits (or just the fact that any have occurred).
## Right now there is the ability to add a timestamp, sampled line count and
## sample prefix.
## A prefix format string driven by a dictionary. Roughly:
## "%(timestamp)s %(sample_count)s %(sample_prefix)" just as a starting point.
## Use %(x)s so that we can use strings to pad when something isn't used.
## E.g.  if we're not timestamping, then prefix_dict["timestamp"] = " " *
## timestamp_field_width.
## It'll be annoying to have to update the dict for rapidly changing values
## like sample count or grep hits. There may be a better way.
## @todo XXX Add prefix status string.

## @todo XXX Add remote control via signals or other method.
## Motivation: Send a signal and have it dump all current grep hits.
## @todo XXX Add remote control via signals or other method.

# Regular variable names are strings. So we'll use a non-string for some
# special, internal codes. This `var' holds the constructor of the chosen
# Ticker*_t
# There cannot be an accidental name collision this way.
class CTOR_t:
    def __init__(self):
        self.info = "I am the key of the appropriate ticker constructor."

CTOR = CTOR_t()

parse_debug = 0

def identity(x, *args, **kw_args):
    if args:
	return [x] + args
    return x

def true(*args, **kwargs):
    return True

def false(*args, **kwargs):
    return False

def eval_with_units(num, allow_fractions_p=False):
    if (num == "-1"):
        return False                    # No limit
    return dp_utils.numWithUnits(num, allow_fractions_p=allow_fractions_p)

def eval_with_units_fractions_ok(num):
    return eval_with_units(num, allow_fractions_p=True)

def add_to_dict_action(actor, dictionary, parser, namespace, values,
                       option_string=None, dest=None, ext_dict=False):
    if parse_debug:
        print 'dest: %s, ns: %r, values: %r, ostr: %r' % (actor.dest,
                                                          namespace,
                                                          values,
                                                          option_string)
    dest = dest or actor.dest
    if ext_dict:
        dictionary.update(ext_dict)
    else:
        dictionary[dest] = values
    if type(dest) == types.StringType:
        setattr(namespace, dest, values)

App_arg_dict = {CTOR: ticker_lib.Ticker_t}

Ctor_arg_dict = {}

class Ctor_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None,
                 dest=None, ext_dict=False):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace,
                           values, option_string, dest=dest,
                           ext_dict=ext_dict)

class Ctor_arg_action_true(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, True,
                           option_string=None)

class Ctor_arg_action_false(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, False,
                           option_string=None)

class Ctor_arg_action_char(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, values,
                           option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)

class Ctor_arg_action_dots(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, ".",
                                      option_string=option_string)
    
class Ctor_arg_action_char_and_char_wise(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, values,
                                     option_string=option_string)
        add_to_dict_action(self, App_arg_dict, parser, namespace, True,
                           dest="char_wise_p")

class Ctor_arg_action_dots_and_char_wise(Ctor_arg_action_char_and_char_wise):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char_and_char_wise.__call__(self,
                                                    parser, namespace, ".",
                                                    option_string=option_string)

#
# Set tick interval to value, set tick_char to "."
class App_arg_action_DOTS(argparse.Action):
    # set interval
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)
        setattr(namespace, self.dest, values)
        # Set tick char = '.'
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, ".",
                           dest="tick_char")
class App_arg_action_catlike(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        # Just be a pass through. Useful with -g.
        setattr(namespace, "sample_lines_tick_p", true)
        setattr(namespace, "tick_interval", 1)
        setattr(namespace, "sample_lines_tick_prefix", False)

Convenience_opts = (("U_extension", ".log"), ("add_timestamp_p", True))

def set_convenience_opts(namespace):
    for name, val in Convenience_opts:
        setattr(namespace, name, val)

def show_convenience_opts():
    ret = ""
    l = len(Convenience_opts)
    if l > 1:
        sep = ", "
    for name, val in Convenience_opts:
        if l == 1:
            sep = ""
        ret += "%s: %s" % (name, val) + sep
        l -= 1
    return ret

class App_action_log_file_convenience(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "output_files_required_p", True)

class App_action_log_file_convenience_sampled(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "sample_lines_tick_p", True)
        setattr(namespace, "output_files_required_p", True)

class Ctor_arg_action_twiddle(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action.__call__(self, parser, namespace, values,
                                 option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Twiddle_ticker_t,
                           option_string, CTOR)


if __name__ == "__main__":
    import optparse
    def_tick_interval = 100
    ostream = sys.stdout
    default_match_ostream = sys.stdout
    def_pipe_stream = sys.stdout
    pipe_stream = def_pipe_stream
    open_mode = 'w'
    outputStreams = []
    file_suffix = ""
    matching_lines = []
    line_number = 0
    Ctor_arg_dict["max_output_units_before_newline"] = 80 * 100
    append_p = False
    default_compression_level = 5
    GZIP_MAX_COMPRESSION_LEVEL = 9
    ## Each -Z adds one, and we want a single -Z to yield max compression.

    # tick_interval, increment=1, init_string="counting: ", comma=", ",
    # init_count=0, tick_char

    oparser = argparse.ArgumentParser()

    oparser.add_argument("--debug",
                         dest="debug_level", type=int, default=0)
    oparser.add_argument("-i", "--tick-interval",
                         dest="tick_interval", type=eval_with_units,
                         default=def_tick_interval,
                         help="Set ticker's tick interval.")
    oparser.add_argument("-T", "--show-twiddles",
                         dest="show_twiddles_p", default=False,
                         action="store_true",
                         help="Show list of available twiddles.")
    oparser.add_argument("-s", "--sample-lines",
                         dest="sample_lines_tick_p", default=False,
                         action="store_true",
                         help="Tick with input line samples.")
    oparser.add_argument("-S", "--sample-lines-prefix",
                         dest="sample_lines_tick_prefix", default="th-line>",
                         action=Ctor_arg_action,
                         help="Prefix for sampled lines.")
    oparser.add_argument("-A", "--no-clobber",
                         dest="no_clobber_p", default=False,
                         action="store_true",
                         help="Don't clobber existing files. Exit.")
    oparser.add_argument("-Z", "--compression-level",
                         dest="compression_level", type=int,
                         help="Compression level.")
    oparser.add_argument("-z", "--compress",
                         dest="compression_level",
                         const=default_compression_level,
                         action="store_const",
                         help="Set compression level to %s." % (default_compression_level))
    oparser.add_argument("-9", "--z9", "--gzip9",
                         dest="compression_level",
                         const=GZIP_MAX_COMPRESSION_LEVEL,
                         action="store_const",
                         help="Set compression level to %s." % (GZIP_MAX_COMPRESSION_LEVEL))
    oparser.add_argument("-u", "--timestamp-log-files",
                         dest="add_timestamp_p", default=False,
                         action="store_true",
                         help="Add uniquifying timestamp to output file name.")
    oparser.add_argument("-E", "--extension",
                         dest="U_extension", default="",
                         type=str,
                         help=("Addition output file extension. "
                         "Added last, after timestamp [if present]."))
    oparser.add_argument("-l", "--log-file",
                         dest="U_extension", const=".log",
                         action="store_const",
                         help="Add .log suffix.")
    oparser.add_argument("--log",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         # Special action needed because multiple vars are
                         # being changed.
                         action=App_action_log_file_convenience,
                         help=("Save to log file with useful defaults:\n" +
                               show_convenience_opts()))
    oparser.add_argument("--slog",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         action=App_action_log_file_convenience_sampled,
                         help="As --log plus sampled ticking.")
    oparser.add_argument("-U", "--show-units",
                         dest="show_tick_units_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Print units [chars, lines] with output.")
    oparser.add_argument("--timestamp", "--ts",
                         dest="timestamp_p", default=False,
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Add a timestamp to ticks. Best with sampled output.")
    oparser.add_argument("-I", "--increment",
                         dest="increment", type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Increment")
    oparser.add_argument("-m", "--max-output-line-len",
                         dest="max_output_units_before_newline",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks per line")
    oparser.add_argument("-M", "--max-output",
                         dest="max_output_units_before_exit",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks before exiting.")
    oparser.add_argument("-P", "--prefix", "--initial-string",
                         dest="init_string",
                         action=Ctor_arg_action,
                         help="Initial prefix string.")
    oparser.add_argument("-C", "--comma", "--count-separator", "--separator",
                         dest="comma",
                         action=Ctor_arg_action,
                         help="Separator character between ticks.")
    oparser.add_argument("--initial-count",
                         dest="init_count",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Initial count [number of units]")
    oparser.add_argument("-c", "--tick-char",
                         dest="tick_char", default=None,
                         action=Ctor_arg_action,
                         help="""Tick character. Mutually exclusive with twiddle.
Implies Char_ticker_t""")
    oparser.add_argument("-d", "--dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots,
                         help="Use dots for tick char. Implies Char_ticker_t.")
    oparser.add_argument("-.", "--char-dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots_and_char_wise,
                         help="Char_ticker_t, count chars, tick with '.'.")
    oparser.add_argument("-D", "--DOTS",
                         dest="tick_interval",
                         type=eval_with_units,
                         action=App_arg_action_DOTS,
                         help="Like --dots + tick interval.")
    oparser.add_argument("-t", "--twiddle",
                         dest="twiddle_chars", type=int,
                         action=Ctor_arg_action_twiddle,
                         help="Set twiddle chars. Implies Twiddle_ticker_t")
    oparser.add_argument("-G", "--print-grand-total", "--grand-total",
                         dest="grand_total_p", default=True,
                         nargs=0,
                         action=Ctor_arg_action_false,
                         help="Print grand total at end.")
    oparser.add_argument("-k", "--char-wise",
                         dest="char_wise_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Count chars vs lines [the default].")
    oparser.add_argument("-K", "--char-wise-char", "--char-tick-char",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_char_and_char_wise,
                         help="Count chars vs lines [the default] and set tick char.")
    oparser.add_argument("-p", "-e", "--pipe-mode", "--output-to-stderr",
                         "--tick-to-stderr",
                         dest="pipe_mode_p", default=False,
                         action="store_true",
                         help="Send ticks to stderr and input to stdout.")
    oparser.add_argument("-g", "--grep", "--regexp", "--re",
                         dest="regexp_patterns",
                         action="append", default=[],
                         help='Grep for these patterns and treat "specially".')
    oparser.add_argument("--tgen-errors",
                         default=None, const="Assertion|call stack|stack_trace",
                         action="store_const",
                         help="Convenience option for finding common testgen errors. Perhaps change the value of this to an envvar to make it more flexible.  --log-errors-regexp")

    oparser.add_argument("--project-log-errors",
                         default=None,
                         const=os.environ.get("TEEKER_PROJECT_LOG_ERROR_REGEXP", None),
                         action="store_const",
                         help="Convenience option for finding common testgen errors. Perhaps change the value of this to an envvar to make it more flexible.  --log-errors-regexp")

    oparser.add_argument("--go", "--grep-ostream", "--grep-ofile", "--reo",
                         "--regexp-ostream", "--re-ostream", "--match-ofile",
                         dest="match_ostream",
                         default=None,
                         help='Print matching lines to this stream.')
    oparser.add_argument("--max-matches", "--max-hits", "--mm",
                         dest="max_regexp_matches_before_exit",
                         type=int, default=0, # == 0 --> unlimited.
                         help="Max regexp matches before exit.")
    oparser.add_argument("-q", "--cat-like", "--copy",
                         nargs=0,
                         action=App_arg_action_catlike,
                         help="Just be a pass through. Useful when grepping.")
    oparser.add_argument("--highlight-grep", "--highlight-matches",
                         "--high-grep", "--high_matches",
                         "--hl-grep", "--hl-matches",
                         "--hi-grep", "--hi-matches",
                         "--hgrep", "--hmatches",
                         "--hg", "--hm",
                         dest="highlight_grep_matches_p", default=False,
                         action="store_true",
                         help="Show matches as they occur.")
    oparser.add_argument("--no-grep-summary", "--no-match-summary",
                         dest="match_summary_p", default=True,
                         action="store_false",
                         help="Don't show all grep matches at end of run.")
    
    # tee(1) compatibility.
    oparser.add_argument("-a", "--append",
                         dest="append_p", default=False,
                         action="store_true",
                         help="Append data to output file(s).")

    oparser.add_argument("output_files", nargs="*")

    app_args = oparser.parse_args()

    print "app_args.debug level:", app_args.debug_level
    dp_io.set_debug_level(app_args.debug_level, enable_debugging_p=True)
    print "debug level:", dp_io.get_debug_level()
    dp_io.cdebug(1, "app_args: %s\n", app_args)
    dp_io.cdebug(1, "Ctor_arg_dict: %s\n", Ctor_arg_dict)
    dp_io.cdebug(1, "App_arg_dict: %s\n", App_arg_dict)

    ticker_constructor = App_arg_dict.pop(CTOR)

    compress_p = app_args.compression_level >= 0

    if app_args.match_ostream is None:
        app_args.match_ostream = default_match_ostream
    else:
        mos = eval(app_args.match_ostream)
        os_type = type(mos)
        if os_type == types.StringType:
            app_args.match_ostream = open(app_args.mos, "w")
        elif os_type == types.FileType:
            app_args.match_ostream = mos
        else:
            raise exceptions.TypeError

    if app_args.show_twiddles_p:
        ticker_lib.Twiddle_twiddles()
        sys.exit(0)

    if app_args.append_p:
        open_mode = "a"

    if app_args.add_timestamp_p:
        file_suffix = "." + dp_utils.bq("dp-std-timestamp")
    file_suffix += app_args.U_extension

    dp_io.cdebug(1, "app_args.output_files>%s<\n", app_args.output_files)
    if len(app_args.output_files) == 0 and app_args.output_files_required_p:
        dp_io.eprintf("One or more log file names are required.\n")
        sys.exit(1)
        
    for a in app_args.output_files:
        dp_io.cdebug(2,"log file name>%s<\n", a)
        a = a + file_suffix
        dp_io.cdebug(2,"output file name>%s<\n", a)
        if app_args.no_clobber_p:
            if os.path.exists(a):
                dp_io.eprintf("File [%s] exists: not clobbering\n", a)
                sys.exit(1)
        if compress_p:
            dp_io.cdebug(2, "compression: %d\n", app_args.compression_level)
            fobj = gzip.open(a + ".gz", open_mode, app_args.compression_level)
        else:
            fobj = open(a, open_mode)

        # I *love* duck typing.
        outputStreams.append(fobj)


    #!<@todo Check for twiddle ticker request and handle that.
    #print "Ctor_arg_dict:", Ctor_arg_dict
    # pipe mode: Ticks go to stderr and lines go to stdout.
    pipe_mode_p, char_wise_p = (app_args.pipe_mode_p, app_args.char_wise_p)

    #if Ctor_arg_dict.get("twiddle_chars", False) != False:
    #    Ctor_arg_dict["init_string"] = ""
    #
    if Ctor_arg_dict.get("init_string", False) == False:
        if char_wise_p:
            Ctor_arg_dict["init_string"] = "Counting chars: "
            Ctor_arg_dict["unit_name"] = 'char'
        else:
            Ctor_arg_dict["init_string"] = "Counting lines: "
            Ctor_arg_dict["unit_name"] = 'line'

    if pipe_mode_p:
        Ctor_arg_dict["ostream"] = sys.stderr
    else:
        Ctor_arg_dict["ostream"] = ostream

    if app_args.sample_lines_tick_p:
        Ctor_arg_dict["init_string"] = "Sampling every %sth line\n" % (
            app_args.tick_interval)
        Ctor_arg_dict["unit_name"] = 'line'
        Ctor_arg_dict["comma"] = ""     # Line will end with newline.

    dp_io.cdebug(1, "Final Ctor_arg_dict: %s\n", Ctor_arg_dict)
    ticker = ticker_constructor(app_args.tick_interval, **Ctor_arg_dict)
    if pipe_mode_p:
        outputStreams.append(pipe_stream)
        ostream.write("\n")

    # Help speed up the loop.
    compiled_regexps = []
    if app_args.tgen_errors is not None:
        app_args.highlight_grep_matches_p = True
        app_args.regexp_patterns.append(app_args.tgen_errors)
    for regexp in app_args.regexp_patterns:
        compiled_regexps.append(dp_utils.re_compile_case_convention(regexp))
    sampled_line_prefix = app_args.sample_lines_tick_prefix or ""
    dp_io.cdebug(2, "sampled_line_prefix>%s<\n", sampled_line_prefix)
    dp_io.cdebug(2, "app_args.sample_lines_tick_prefix>%s<\n",
                 app_args.sample_lines_tick_prefix)
    max_hits = app_args.max_regexp_matches_before_exit
    while True:
	input_line = sys.stdin.readline()
	if (not input_line or
            (max_hits and (len(matching_lines) >= max_hits))):
            if app_args.match_summary_p and matching_lines:
                print "\n================="
                print "Num matching lines:", len(matching_lines)
                tlos = outputStreams.append(sys.stdout)
                for lt in  matching_lines:
                    for o in outputStreams:
                        o.write("Matching line: %s: %s\n" % (lt[1],
                                                             lt[0][:-1]))
                print "================="
            ticker.fini()
            break
        line_number += 1
        for o in outputStreams:
            o.write(input_line)
        for regexp in compiled_regexps:
            if regexp.search(input_line):
                matching_lines.append((input_line, line_number))
                if app_args.highlight_grep_matches_p:
                    # XXX @todo Add ANSI color options?
                    dp_io.fprintf(app_args.match_ostream,
                                  "\n*** line: %d, >%s< ***\n",
                                  line_number, input_line[:-1])
                break
        if char_wise_p:
            # Iterate for each char in the line.
            for c in input_line:
                if app_args.sample_lines_tick_p:
                    tick = sampled_line_prefix + c
                else:
                    tick = None
                ticker(tick=tick)
        else:
            if app_args.sample_lines_tick_p:
                # @todo XXX allow a format to be used (dictionary type)
                tick = ""
                if app_args.sample_lines_tick_prefix is not False:
                    tick =  "%8d" % (ticker.counter,)
                tick += sampled_line_prefix + input_line
            else:
                tick = None
            ticker(tick=tick)
    print
