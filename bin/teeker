#!/usr/bin/env python

import os, sys, string, types, re, exceptions, signal
import gzip, argparse
import dp_utils, ticker_lib, dp_io, dp_time

Caught_signals = []

## Tickers
## Tickers count "lines of input." This is really just the number of calls to
## the ticker instance's __call__() method.
## A base ticker does it with number of lines.
## A char ticker does it with characters.
## A twiddle ticker ticks in one place, cycling through a char set, like
## bsd's boot ticker.

## Teeker
## Char wise means split input lines into chars and feed them 1 by 1 into the
## ticker. This can be any kind of ticker. Each character is one "line" of
## input to the underlying ticker.

## @todo XXX Add prefix status string.
## E.g. track number of grep hits (or just the fact that any have occurred).
## Right now there is the ability to add a timestamp, sampled line count and
## sample prefix.
## A prefix format string driven by a dictionary. Roughly:
## "%(timestamp)s %(sample_count)s %(sample_prefix)" just as a starting point.
## Print everything as a string, i.e. use %(x)s so that we can use strings to
## pad when something isn't used.
## E.g.  if we're not timestamping, then prefix_dict["timestamp"] = " " *
## timestamp_field_width.
## It'll be annoying to have to update the dict for rapidly changing values
## like sample count or grep hits. There may be a better way.
## @todo XXX Add prefix status string.

## @todo XXX Add remote control via signals or other method.
## Motivation: Send a signal and have it dump all current grep hits.
## @todo XXX Add remote control via signals or other method.

# Regular variable names are strings. So we'll use a non-string for some
# special, internal codes. This `var' holds the constructor of the chosen
# Ticker*_t
# There cannot be an accidental name collision this way.
class CTOR_t:
    def __init__(self):
        self.info = "I am the key of the appropriate ticker constructor."


DEFAULT_ERROR_INDICATOR = "!"
DEFAULT_EGREP_PREFIX = DEFAULT_ERROR_INDICATOR * 4
DEFAULT_EGREP_SUFFIX = DEFAULT_ERROR_INDICATOR * 4
DEFAULT_MATCH_INDICATOR = "@"
DEFAULT_MATCH_PREFIX = DEFAULT_MATCH_INDICATOR * 3
DEFAULT_MATCH_SUFFIX = DEFAULT_MATCH_INDICATOR * 3
DEFAULT_INDICATOR_SEPARATOR = "|"
DEFAULT_MAX_ERROR_MATCHES = 0
DEFAULT_LINES_AFTER = -1                # None

tick_counter_prefix_format = "%s%s"
tick_counter_count_format = "%8d"
tick_counter_format = tick_counter_prefix_format + tick_counter_count_format
tick_counter_min_width = len(tick_counter_format % (DEFAULT_ERROR_INDICATOR,
                                                    DEFAULT_MATCH_INDICATOR,
                                                    0))
# The timestamp is generated inside the ticker object.
# This will need to track that.
timestamp_width = len("2013-05-16T18.37.54")

## A prefix format string driven by a dictionary. Roughly:
## "%(timestamp)s %(sample_count)s %(sample_prefix)" just as a starting point.
## Print everything as a string, i.e. use %(x)s so that we can use strings to
## pad when something isn't used.
## E.g.  if we're not timestamping, then prefix_dict["timestamp"] = " " *
## timestamp_field_width.
## It'll be annoying to have to update the dict for rapidly changing values
## like sample count or grep hits. There may be a better way.
## NB timestamp is printed inside the ticker lib.

Prefix_format_string = """%(egrep_hit)s%(grep_hit)s%(sample_prefix)"""

Prefix_variables = {
    "egrep_hit": " ",                   # Shows if an error regexp found.
    "grep_hit": " ",                 # Shows if a non-error regexp was found.
    "sample_prefix": " " * tick_counter_min_width,
}    
    

CTOR = CTOR_t()

parse_debug = 0

def signal_handler(signal, frame):
    Caught_signals.append("%s" % (signal,))

signal.signal(signal.SIGINT, signal_handler)


def identity(x, *args, **kw_args):
    if args:
	return [x] + args
    return x

def true(*args, **kwargs):
    return True

def false(*args, **kwargs):
    return False

def Catlike_setup(namespace):
    setattr(namespace, "sample_lines_tick_p", true)
    setattr(namespace, "tick_interval", 1)
    setattr(namespace, "sample_lines_tick_prefix", False)

def eval_with_units(num, allow_fractions_p=False):
    if (num == "-1"):
        return False                    # No limit
    return dp_utils.numWithUnits(num, allow_fractions_p=allow_fractions_p)

def eval_with_units_fractions_ok(num):
    return eval_with_units(num, allow_fractions_p=True)

# Funnel through here for debugging.
def add_to_dict_action(actor, dictionary, parser, namespace, values,
                       option_string=None, dest=None, ext_dict=False):
    if parse_debug:
        print 'dest: %s, ns: %r, values: %r, ostr: %r' % (actor.dest,
                                                          namespace,
                                                          values,
                                                          option_string)
    dest = dest or actor.dest
    if ext_dict:
        dictionary.update(ext_dict)
    else:
        dictionary[dest] = values
    if type(dest) == types.StringType:
        setattr(namespace, dest, values)

App_arg_dict = {CTOR: ticker_lib.Ticker_t}

Ctor_arg_dict = {}

class Ctor_arg_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None,
                 dest=None, ext_dict=False):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace,
                           values, option_string, dest=dest,
                           ext_dict=ext_dict)

class App_arg_action_ctor(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None,
                 dest=None, ext_dict=False):
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)
        add_to_dict_action(self, App_arg_dict, parser, namespace, True,
                           dest="char_wise_p")

class Ctor_arg_action_true(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, True,
                           option_string=None)

class Ctor_arg_action_false(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, False,
                           option_string=None)

class Ctor_arg_action_char(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, values,
                           option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)

class Ctor_arg_action_dots(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, ".",
                                      option_string=option_string)
    
class Ctor_arg_action_char_and_char_wise(Ctor_arg_action_char):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char.__call__(self, parser, namespace, values,
                                     option_string=option_string)
        add_to_dict_action(self, App_arg_dict, parser, namespace, True,
                           dest="char_wise_p")

class Ctor_arg_action_dots_and_char_wise(Ctor_arg_action_char_and_char_wise):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action_char_and_char_wise.__call__(self,
                                                    parser, namespace, ".",
                                                    option_string=option_string)

#
# Set tick interval to value, set tick_char to "."
class App_arg_action_DOTS(argparse.Action):
    # set interval
    def __call__(self, parser, namespace, values, option_string=None):
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Char_ticker_t,
                           option_string, CTOR)
        setattr(namespace, self.dest, values)
        # Set tick char = '.'
        add_to_dict_action(self, Ctor_arg_dict, parser, namespace, ".",
                           dest="tick_char")

class App_arg_action_catlike(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        # Just be a pass through. Useful with -g.
        Catlike_setup(namespace)

class App_arg_action_add_regexp_and_highlight(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        regexps = getattr(namespace, self.dest)
        regexps.append(values)
        setattr(namespace, self.dest, regexps)
        setattr(namespace, "highlight_grep_matches_p", True) 

Convenience_opts = (("U_extension", ".log"), ("add_timestamp_p", True))

def set_convenience_opts(namespace):
    for name, val in Convenience_opts:
        setattr(namespace, name, val)

def show_convenience_opts():
    ret = ""
    l = len(Convenience_opts)
    if l > 1:
        sep = ", "
    for name, val in Convenience_opts:
        if l == 1:
            sep = ""
        ret += "%s: %s" % (name, val) + sep
        l -= 1
    return ret

class App_action_log_file_convenience(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "output_files_required_p", True)

class App_action_log_file_convenience_sampled(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "sample_lines_tick_p", True)
        setattr(namespace, "output_files_required_p", True)

class App_action_log_file_convenience_sampled_timestamped(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        set_convenience_opts(namespace)
        setattr(namespace, "sample_lines_tick_p", True)
        setattr(namespace, "output_files_required_p", True)
        Ctor_arg_dict["timestamp_p"] = True

class Ctor_arg_action_twiddle(Ctor_arg_action):
    def __call__(self, parser, namespace, values, option_string=None):
        Ctor_arg_action.__call__(self, parser, namespace, values,
                                 option_string=None)
        add_to_dict_action(self, App_arg_dict, parser, namespace,
                           ticker_lib.Twiddle_ticker_t,
                           option_string, CTOR)


def display_match(ostream, line, line_number, prefix="", suffix="",
                  timestamp_p=False):
    if timestamp_p:
        ts = dp_time.std_timestamp() + ": "
    else:
        ts = ""
    dp_io.fprintf(ostream, "%s %sline: %d, >%s< %s",
                  prefix, ts, line_number, line, suffix)
    app_args.match_ostream.flush()

def dump_matching_and_error_lines(all_output_streams,
                                  matching_lines,
                                  error_lines,
                                  wing_size=7,
                                  wing_string="="):
    all_output_streams = outputStreams + [sys.stdout]
    wing = wing_size * wing_string
    title = wing + " Matching line summary " + wing
    sep_line = len(title) * "="
    dp_io.printf("\n" + title + "\n")
    dp_io.printf("Regexp matches: %s, error matches: %s\n",
                 len(matching_lines), len(error_lines))
    if matching_lines:
        dp_io.printf("matching lines: %s\n", len(matching_lines))
        for lt in  matching_lines:
            match = lt[1]
            line = lt[0][:-1]
            for o in all_output_streams:
                o.write("Matching line: %s>%s<\n" % (match, line))

    if error_lines:
        dp_io.printf("\n" + sep_line + "\n")
        dp_io.printf("Num error lines: %s\n", len(error_lines))
        for lt in error_lines:
            match = lt[1]
            line = lt[0][:-1]
            for o in all_output_streams:
                o.write("Matching line: %s>%s<\n" % (match, line))
    dp_io.printf(sep_line + "\n")
    
if __name__ == "__main__":
    import optparse
    def_tick_interval = 100
    ostream = sys.stdout
    default_match_ostream = sys.stdout
    def_pipe_stream = sys.stdout
    pipe_stream = def_pipe_stream
    open_mode = 'w'
    outputStreams = []
    file_suffix = ""
    matching_lines = []
    error_lines = []
    error_indicator = " "
    match_indicator = " "
    indicator_separator = " "
    line_number = 0
    Ctor_arg_dict["max_output_units_before_newline"] = 80 * 100
    append_p = False
    default_compression_level = 5
    GZIP_MAX_COMPRESSION_LEVEL = 9
    total_bytes_written = 0
    ## Each -Z adds one, and we want a single -Z to yield max compression.

    # tick_interval, increment=1, init_string="counting: ", comma=", ",
    # init_count=0, tick_char

    oparser = argparse.ArgumentParser()

    oparser.add_argument("--debug",
                         dest="debug_level", type=int, default=0)
    oparser.add_argument("--quiet",
                         dest="quiet_p", default=False,
                         action="store_true",
                         help="Do not print informative messages.")
    oparser.add_argument("-i", "--tick-interval",
                         dest="tick_interval", type=eval_with_units,
                         default=def_tick_interval,
                         help="Set ticker's tick interval.")
    oparser.add_argument("-T", "--show-twiddles",
                         dest="show_twiddles_p", default=False,
                         action="store_true",
                         help="Show list of available twiddles.")
    oparser.add_argument("-s", "--sample-lines",
                         dest="sample_lines_tick_p", default=False,
                         action="store_true",
                         help="Tick with input line samples.")
    oparser.add_argument("-S", "--sample-lines-prefix",
                         dest="sample_lines_tick_prefix", default="th-line>",
                         action=Ctor_arg_action,
                         help="Prefix for sampled lines.")
    oparser.add_argument("--no-clobber",
                         dest="no_clobber_p", default=False,
                         action="store_true",
                         help="Don't clobber existing files. Exit.")
    oparser.add_argument("-Z", "--compression-level",
                         dest="compression_level", type=int,
                         help="Compression level.")
    oparser.add_argument("-z", "--compress",
                         dest="compression_level",
                         const=default_compression_level,
                         action="store_const",
                         help="Set compression level to %s." % (default_compression_level))
    oparser.add_argument("-9", "--z9", "--gzip9",
                         dest="compression_level",
                         const=GZIP_MAX_COMPRESSION_LEVEL,
                         action="store_const",
                         help=("Set compression level to %s." %
                               (GZIP_MAX_COMPRESSION_LEVEL)))
    oparser.add_argument("-u", "--timestamp-log-files",
                         dest="add_timestamp_p", default=False,
                         action="store_true",
                         help="Add uniquifying timestamp to output file name.")
    oparser.add_argument("-E", "--extension",
                         dest="U_extension", default="",
                         type=str,
                         help=("Addition output file extension. "
                         "Added last, after timestamp [if present]."))
    oparser.add_argument("-l", "--log-file",
                         dest="U_extension", const=".log",
                         action="store_const",
                         help="Add .log suffix.")
    oparser.add_argument("--log",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         # Special action needed because multiple vars are
                         # being changed.
                         action=App_action_log_file_convenience,
                         help=("Save to log file with useful defaults:\n" +
                               show_convenience_opts()))
    oparser.add_argument("--slog", "--sampled-log",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         action=App_action_log_file_convenience_sampled,
                         help="As --log plus sampled ticking.")
    oparser.add_argument("--tslog", "--timestamped-sampled-log",
                         dest="output_files_required_p", default=False,
                         nargs=0,
                         action=App_action_log_file_convenience_sampled_timestamped,
                         help="As --slog plus timestamping.")
    oparser.add_argument("-U", "--show-units",
                         dest="show_tick_units_p",
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Print units [chars, lines] with output.")
    oparser.add_argument("--timestamp", "--ts",
                         dest="timestamp_p", default=False,
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Add a timestamp to ticks. Nice with sampled output.")
    oparser.add_argument("--elapsed-timestamp", "--ets",
                         dest="elapsed_timestamp_p", default=False,
                         nargs=0,
                         action=Ctor_arg_action_true,
                         help="Add an elapsed timestamp to ticks. Nice with sampled output.")
    oparser.add_argument("-I", "--increment",
                         dest="increment", type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Increment")
    oparser.add_argument("-m", "--max-output-line-len",
                         dest="max_output_units_before_newline",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks per line")
    oparser.add_argument("-M", "--max-output",
                         dest="max_output_units_before_exit",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Maximum ticks before exiting.")
    oparser.add_argument("--max-log-file-size", "--max-bytes-written",
                         dest="max_output_bytes_before_exit",
                         default=False,
                         type=eval_with_units,
                         help="Maximum bytes before exiting.")
    oparser.add_argument("-P", "--prefix", "--initial-string",
                         dest="init_string",
                         action=Ctor_arg_action,
                         help="Initial prefix string.")
    oparser.add_argument("-C", "--comma", "--count-separator", "--separator",
                         dest="comma",
                         action=Ctor_arg_action,
                         help="Separator character between ticks.")
    oparser.add_argument("--initial-count",
                         dest="init_count",
                         type=eval_with_units,
                         action=Ctor_arg_action,
                         help="Initial count [number of units]")
    oparser.add_argument("-c", "--tick-char",
                         dest="tick_char", default=None,
                         action=Ctor_arg_action_char,
                         help="""Tick character. Mutually exclusive with twiddle.
Implies Char_ticker_t""")
    oparser.add_argument("-d", "--dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots,
                         help="Use dots for tick char. Implies Char_ticker_t.")
    oparser.add_argument("-.", "--char-dots",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_dots_and_char_wise,
                         help="Char_ticker_t, count chars, tick with '.'.")
    oparser.add_argument("-D", "--DOTS",
                         dest="tick_interval",
                         type=eval_with_units,
                         action=App_arg_action_DOTS,
                         help="Like --dots + tick interval.")
    oparser.add_argument("-t", "--twiddle",
                         dest="twiddle_chars", type=int,
                         action=Ctor_arg_action_twiddle,
                         help="Set twiddle chars. Implies Twiddle_ticker_t")
    oparser.add_argument("-G", "--print-grand-total", "--grand-total",
                         dest="grand_total_p", default=True,
                         nargs=0,
                         action=Ctor_arg_action_false,
                         help="Print grand total at end.")
    oparser.add_argument("-k", "--char-wise",
                         dest="char_wise_p", default=False,
                         action="store_true",
                         help="""Count chars vs lines [the default].
Split line into chars and feed to ticker.""")
    oparser.add_argument("-K", "--char-wise-char", "--char-tick-char",
                         dest="tick_char",
                         nargs=0,
                         action=Ctor_arg_action_char_and_char_wise,
                         help="Count chars vs lines [the default] and set tick char.")
    oparser.add_argument("-p", "-e", "--pipe-mode", "--output-to-stderr",
                         "--tick-to-stderr",
                         dest="pipe_mode_p", default=False,
                         action="store_true",
                         help="Send ticks to stderr and input to stdout.")
    oparser.add_argument("-g", "--grep", "--regexp", "--re", "--match",
                         dest="regexp_patterns",
                         action="append", default=[],
                         help='Grep for these patterns.')
    oparser.add_argument("--hgrep", "--hregexp", "--hmatch",
                         dest="regexp_patterns", default=[],
                         action=App_arg_action_add_regexp_and_highlight,
                         help='Grep for these patterns and highlight.')
    oparser.add_argument("--grep-hit-action",
                         dest="grep_hit_action", default="",
                         type=str,
                         help="Run this when there is a pattern match.")
    oparser.add_argument("--all-grep-hits-action",
                         dest="all_grep_hit_actions_p", default=False,
                         action="store_true",
                         help="Run the grep hit action on all grep hits.")
    oparser.add_argument("--tgen-errors",
                         default=None, const="Assertion|call stack|stack_trace",
                         action="store_const",
                         help="Convenience option for finding common testgen errors. Perhaps change the value of this to an envvar to make it more flexible.  --log-errors-regexp")
    oparser.add_argument("-grep-errors", "--errors", "--error-regexps",
                         "--ere", "--egrep",
                         dest="error_regexp_patterns",
                         action="append", default=[],
                         help="Grep for these patterns and treat as errors. --max-errors tells how many error matches to accept before exiting. The default is %s where 0 means no limit." % (DEFAULT_MAX_ERROR_MATCHES,))
    oparser.add_argument("--project-log-errors",
                         default=None,
                         const=os.environ.get("TEEKER_PROJECT_LOG_ERROR_REGEXP", None),
                         action="store_const",
                         help="Convenience option for finding common testgen errors. Perhaps change the value of this to an envvar to make it more flexible.  --log-errors-regexp")
    oparser.add_argument("--go", "--grep-ostream", "--grep-ofile", "--reo",
                         "--regexp-ostream", "--re-ostream", "--match-ofile",
                         dest="match_ostream",
                         default=None,
                         help='Print matching lines to this stream.')
    oparser.add_argument("--max-matches", "--max-hits", "--mm",
                         dest="max_regexp_matches_before_exit",
                         type=int, default=0, # == 0 --> unlimited.
                         help="Max regexp matches before exit.")
    oparser.add_argument("--max-errors", "--max-errs", "--max-error-hits",
                         "--meh", "--emax", "--maxe",
                         dest="max_error_regexp_matches_before_exit",
                          # == 0 --> unlimited.
                         type=int, default=DEFAULT_MAX_ERROR_MATCHES,
                         help="Max error regexp matches before exit.")
    oparser.add_argument("--lines-after", "-A",
                         dest="num_lines_to_print_after",
                         type=int, default=DEFAULT_LINES_AFTER,
                         help="Print this many more lines if possible (ignoring filters and ticking) when exiting. Default is: %s. (< 0) means none")
    oparser.add_argument("-q", "--cat-like", "--copy",
                         nargs=0,
                         action=App_arg_action_catlike,
                         help="Just be a pass through. Useful when grepping.")
    oparser.add_argument("--highlight-grep", "--highlight-matches",
                         "--high-grep", "--high_matches",
                         "--hl-grep", "--hl-matches",
                         "--hi-grep", "--hi-matches",
                         "--hmatches",
                         "--hg", "--hm",
                         dest="highlight_grep_matches_p", default=None,
                         action="store_true",
                         help="Show matches as they occur.")
    oparser.add_argument("--no-highlight-grep", "--no-highlight-matches",
                         "--no-high-grep", "--no-high_matches",
                         "--no-hl-grep", "--no-hl-matches",
                         "--no-hi-grep", "--no-hi-matches",
                         "--no-hgrep", "--no-hmatches",
                         "--no-hg", "--no-hm",
                         dest="highlight_grep_matches_p",
                         ## Use None as default so we can tell the difference
                         ## between the default and the option having been
                         ## specified.
                         default=None,
                         action="store_false",
                         help="Do not show matches as they occur.")
    oparser.add_argument("--no-grep-summary", "--no-match-summary",
                         dest="match_summary_p", default=True,
                         action="store_false",
                         help="Don't show all grep matches at end of run.")
    oparser.add_argument("--unbuffered-logs",
                         dest="unbuffered_logs_p", default=False,
                         action="store_true")
    oparser.add_argument("--unbuffered-out",
                         dest="unbuffered_out_p", default=False,
                         action="store_true")
    
    # tee(1) compatibility.
    oparser.add_argument("-a", "--append",
                         dest="append_p", default=False,
                         action="store_true",
                         help="Append data to output file(s).")

    oparser.add_argument("output_files", nargs="*")

    app_args = oparser.parse_args()

    if app_args.debug_level:
        print "app_args.debug level:", app_args.debug_level
        dp_io.set_debug_level(app_args.debug_level, enable_debugging_p=True)
        print "dp_io \debug level:", dp_io.get_debug_level()
    dp_io.cdebug(1, "app_args: %s\n", app_args)
    dp_io.cdebug(1, "Ctor_arg_dict: %s\n", Ctor_arg_dict)
    dp_io.cdebug(1, "App_arg_dict: %s\n", App_arg_dict)

    ticker_constructor = App_arg_dict.pop(CTOR)

    compress_p = app_args.compression_level >= 0

    if app_args.match_ostream is None:
        app_args.match_ostream = default_match_ostream
    else:
        mos = eval(app_args.match_ostream)
        os_type = type(mos)
        if os_type == types.StringType:
            app_args.match_ostream = open(app_args.mos, "w")
        elif os_type == types.FileType:
            app_args.match_ostream = mos
        else:
            raise exceptions.TypeError

    if app_args.show_twiddles_p:
        ticker_lib.Twiddle_twiddles()
        sys.exit(0)

    if app_args.append_p:
        open_mode = "a"

    if app_args.add_timestamp_p:
        file_suffix = "." + dp_time.std_timestamp()
    file_suffix += app_args.U_extension

    dp_io.cdebug(1, "app_args.output_files>%s<\n", app_args.output_files)
    if len(app_args.output_files) == 0 and app_args.output_files_required_p:
        dp_io.eprintf("One or more log file names are required.\n")
        sys.exit(1)

    if app_args.unbuffered_out_p:
        dp_io.unbuffer_a_file(sys.stdout)

    sample_ostream = dp_io.Unbuffered_file_duck(sys.stdout)

    for a in app_args.output_files:
        dp_io.cdebug(2,"log file name>%s<\n", a)
        a = a + file_suffix
        if not app_args.quiet_p:
            compression_message = ""
            if compress_p:
                compression_message = ", compression level: %d" % \
                                      (app_args.compression_level)
            dp_io.printf("output file name>%s<%s\n", a, compression_message)
        if app_args.no_clobber_p:
            if os.path.exists(a):
                dp_io.eprintf("File [%s] exists: not clobbering\n", a)
                sys.exit(1)
        if compress_p:
            dp_io.cdebug(2, "compression: %d\n", app_args.compression_level)
            fobj = gzip.open(a + ".gz", open_mode, app_args.compression_level)
        else:
            ## Pass nothing if unbuffered is not set to preserve existing
            ## operation.
            if app_args.unbuffered_logs_p:
                fobj = open(a, open_mode, 0)
            else:
                fobj = open(a, open_mode)

        # I *love* duck typing.
        outputStreams.append(fobj)


    #!<@todo Check for twiddle ticker request and handle that.
    #print "Ctor_arg_dict:", Ctor_arg_dict
    # pipe mode: Ticks go to stderr and lines go to stdout.
    pipe_mode_p, char_wise_p = (app_args.pipe_mode_p, app_args.char_wise_p)

    #if Ctor_arg_dict.get("twiddle_chars", False) != False:
    #    Ctor_arg_dict["init_string"] = ""
    #
    if Ctor_arg_dict.get("init_string", False) == False:
        if char_wise_p:
            Ctor_arg_dict["init_string"] = "Counting chars: "
            Ctor_arg_dict["unit_name"] = 'char'
        else:
            Ctor_arg_dict["init_string"] = "Counting lines: "
            Ctor_arg_dict["unit_name"] = 'line'

    if pipe_mode_p:
        Ctor_arg_dict["ostream"] = sys.stderr
    else:
        Ctor_arg_dict["ostream"] = ostream
    tick_interval = app_args.tick_interval
    if tick_interval == 0:
        tick_interval = None
    else:
        # No ticking --> no samples.
        if app_args.sample_lines_tick_p:
            if tick_interval == 1:
                nth = ""
            elif tick_interval == 2:
                nth = "other "
            elif tick_interval == 3:
                nth = "third "
            else:
                nth =  "%sth " % (tick_interval,)

            Ctor_arg_dict["init_string"] = "Sampling every %sline\n" % (nth,)
            Ctor_arg_dict["unit_name"] = 'line'
            Ctor_arg_dict["comma"] = ""     # Line will end with newline.

    dp_io.cdebug(1, "Final Ctor_arg_dict: %s\n", Ctor_arg_dict)
    ticker = ticker_constructor(tick_interval, **Ctor_arg_dict)
    if pipe_mode_p:
        outputStreams.append(pipe_stream)
        ostream.write("\n")

    timestamp_p = Ctor_arg_dict.get("timestamp_p", False)
    
    # Help speed up the loop.
    compiled_regexps = []
    compiled_error_regexps = []
    if app_args.tgen_errors is not None:
        app_args.error_regexp_patterns.append(app_args.tgen_errors)

    for regexp in app_args.regexp_patterns:
        compiled_regexps.append(dp_utils.re_compile_with_case_convention(regexp))

    highlight_grep_matches_p = app_args.highlight_grep_matches_p
    grepping_for_errors_p = len(app_args.error_regexp_patterns) != 0
    # for now, this is a constant
    highlight_egrep_matches_p = True
    # Only set this when there are error regexps and the user has not
    # explicitly requested no highlighting
    for regexp in app_args.error_regexp_patterns:
        dp_io.cdebug(1, "Error regexp: %s\n", regexp)
        compiled_error_regexps.append(
            dp_utils.re_compile_with_case_convention(regexp))

    sampled_line_prefix = app_args.sample_lines_tick_prefix or ""
    dp_io.cdebug(2, "sampled_line_prefix>%s<\n", sampled_line_prefix)
    dp_io.cdebug(2, "app_args.sample_lines_tick_prefix>%s<\n",
                 app_args.sample_lines_tick_prefix)
    max_hits = app_args.max_regexp_matches_before_exit
    max_error_matches = app_args.max_error_regexp_matches_before_exit
    ticker.flush()
    final_exit_p = False
    limit_exit_p = False

    def loop_fini():
        if app_args.match_summary_p and (matching_lines or error_lines):
            dump_matching_and_error_lines(outputStreams + [sys.stdout],
                                          matching_lines,
                                          error_lines)
        ticker.fini()

    num_lines_to_print_after = app_args.num_lines_to_print_after
    max_output_bytes_before_exit = app_args.max_output_bytes_before_exit
    trailing_lines = -1
    trailing_line_prefix = ""
    while True:
        #print "top: trailing_lines:", trailing_lines
        readline_failed_p = False
        input_line = ""
        try:
            input_line = sys.stdin.readline()
        except Exception, e:
            dp_io.eprintf("readline() failed: %s", e)
            readline_failed_p = True
        final_exit_p = ((not input_line)
                        or readline_failed_p
                        or Caught_signals)

        limit_exit_p = ((grepping_for_errors_p and max_error_matches and
                         (len(error_lines) >= max_error_matches))
                        or ((max_output_bytes_before_exit is not False)
                            and
                            (total_bytes_written > max_output_bytes_before_exit))
                        or (max_hits and (len(matching_lines) >= max_hits)))
        # *exit* condition
        # go when (not limit_exit_p) or trailing_lines > 0 is True
        # exit limit_exit_p and (not trailing_lines > 0) is True
        if (final_exit_p or limit_exit_p):
            if final_exit_p or trailing_lines == 0:
                loop_fini()
                break
            if trailing_lines < 0:
                dp_io.printf("\n" + "=== Post Limit Lines ===" + "\n")
                trailing_lines = num_lines_to_print_after
            else:
                trailing_lines -= 1
            #print "2: trailing_lines:", trailing_lines
            #trailing_line_prefix = "Trailing line: "
        input_line = trailing_line_prefix + input_line
        #print "3: trailing_lines:", trailing_lines
        for o in outputStreams:
            # Since this was motivated by a disk space issue, count *all*
            # writes.
            total_bytes_written += len(input_line)
            o.write(input_line)
        if trailing_lines > 0:
            sys.stdout.write(input_line)
        if limit_exit_p:
            continue
        for regexp in compiled_regexps:
            if regexp.search(input_line):
                matching_lines.append((input_line, line_number))
                match_indicator = DEFAULT_MATCH_INDICATOR
                indicator_separator = DEFAULT_INDICATOR_SEPARATOR
                if highlight_grep_matches_p:
                    # XXX @todo Add ANSI color options?
                    display_match(app_args.match_ostream,
                                  input_line[:-1], line_number,
                                  prefix="\n" + DEFAULT_MATCH_PREFIX,
                                  suffix=DEFAULT_MATCH_SUFFIX + "\n",
                                  timestamp_p=timestamp_p)
                if app_args.grep_hit_action:
                    if not app_args.all_grep_hit_actions_p:
                        app_args.grep_hit_action = None
                    dp_io.printf("Teach me how to run this grep hit action>%s<\n",
                                 app_args.grep_hit_action)

        for regexp in compiled_error_regexps:
            if regexp.search(input_line):
                error_lines.append((input_line, line_number))
                error_indicator = DEFAULT_ERROR_INDICATOR
                indicator_separator = DEFAULT_INDICATOR_SEPARATOR
                if highlight_egrep_matches_p:
                    # XXX @todo Add ANSI color options?
                    display_match(app_args.match_ostream,
                                  input_line[:-1], line_number,
                                  prefix="\n" + DEFAULT_EGREP_PREFIX,
                                  suffix=DEFAULT_EGREP_PREFIX + "\n",
                                  timestamp_p=timestamp_p)

        if char_wise_p:
            # Iterate for each char in the line.
            for c in input_line:
                # Sampled lines makes no sense with char_wise.
                #if app_args.sample_lines_tick_p:
                #    tick = sampled_line_prefix + c
                #else:
                #    tick = None
                tick = None
                ticker(tick=tick)
        else:
            tick_prefix = ""
            if app_args.sample_lines_tick_p:
                # @todo XXX allow a format to be used (dictionary type)
                if error_indicator or match_indicator:
                    tick_prefix = (error_indicator + match_indicator
                                   + indicator_separator)
                if app_args.sample_lines_tick_prefix is not False:
                    tick = tick_counter_count_format % (ticker.counter,)
                else:
                    tick = ""
                tick += sampled_line_prefix + input_line
            else:
                # Let the ticker class do what it will.
                tick = None
            ticker(tick=tick, tick_prefix=tick_prefix, ostream=sample_ostream)
        line_number += 1
    print
