#include <cstdio>
#include <cstdlib>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

typedef enum states_e
{
  OPEN_ME = -1,
  IGNORE_ME = -2,
  OPENED = 1,
}
states_t;

int
main(
  int   argc,
  char* argv[])
{
  size_t  buf_len = 1 * 1024 * 1024;
  char*   buf = new char[buf_len+1];
  char*   bufp = buf;
  size_t  num_buffered = 0;
  size_t  num_written = 0;
  int     fd;
  state_t state = OPEN_ME;
  int     c = ~EOF;
  int     eof = 0;

  while (1) {
    if (eof) {
      if (num_buffered == 0)
        break;
    } else {
      c = getchar();
      if (c == EOF)
        eof = 1;
      else
        putchar(c);               // we are a tee after all
    }
    
    if (state == OPEN_ME) {
      // not open yet, buffer it.
      if (num_buffered >= buf_len) {
        // <:@todo - grow buffer, add another to a list, etc.
        ;                       // drop remaining
      } else {
        *bufp++ = static_cast<char>(c);
        ++num_buffered;
      }
    }
    
    // try to open and write
    if (state == OPEN_ME) {
      fd = open(argv[1], O_WRONLY|O_CREAT|O_TRUNC, 0644);
      if (fd >= 0) {
        state = OPENED;
        // write the current buffer
        char* wbufp = buf;
        while (num_buffered) {
          num_written = write(fd, wbufp, num_buffered);
          if (num_written < 0) {
            state = IGNORE_ME;
            break;
          }
          num_buffered -= num_written;
          wbufp += num_written;
        }
        bufp = buf;
      }
    } else if (state == OPENED && !eof) { // file already opened
      // file opened, become a cat, too.
      if (write(fd, &c, 1) != 1) {
        printf("c>%c<\n", c);
        close(fd);
        state = IGNORE_ME;
      }
    }
  }
  if (fd >= 0)
    close(fd);
  
  return (0);
}

