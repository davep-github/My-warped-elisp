#!/bin/bash

source script-x
set -u
progname="$(basename $0)"
source eexec
eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program

EExec_verbose_msg "@>$@<"
EExec_verbose_msg "#>$#<"
if (($# > 0))
then
    wmctrl_patterns=("$@")
else
    # We may not only want to raise a server type *macs window, so check for
    # the existence of other "kinds."  We try to find the first one in some
    # kind of "useful" order.  If what was the server is killed while another
    # (non-server, d'uh) then the other won't have a "Serv" prefix.  I saw
    # emacs@ once, and I don't know how that title got set.
    wmctrl_patterns=(Serv/Emacs@ /Emacs@ emacs@)
fi
EExec_verbose_msg "#:" "${#wmctrl_patterns[@]}"
#
# if we're running sawfish, then raise emacs, too.
# raise first, since sometimes emacs'll prompt for things
# and gnuclient waits in that case until the prompt is responded to.
#if [ "$EZEC" != "echo" ] && [ "$have_sawfish" = "0" ]
#then
#	sawfish-client -f dp-raise-local-emacs > /dev/null
#fi

#
# This needs to pass the current editing server as a parameter.
# Or xemacs needs to make sure the kill gnuserve hook is called.
# NB this does not work across multiple machines and is, in any event, fvwm
#    specific.
#broken findprog -s FvwmCommandS && {
#broken     FvwmCommand 'AnyEditingServer'
#broken     exit
#broken }

# Drat. I could've been using this for years.
# If I can use ec (which uses) gnuclient or equivalent, then I can use this
# to raise the server's frame.
# This also doesn't fail with the new (to me) elisp server code.

if type wmctrl >/dev/null 2>&1
then
    # Try all options
    echo "# " "${#wmctrl_patterns[@]}"
    for p in "${wmctrl_patterns[@]}"
    do
	echo "p>${p}<"
    done
    for p in "${wmctrl_patterns[@]}"
    do
	EExec -k wmctrl -a "${p}" && exit 0
    done
    exit 1
else
    # This doesn't work in my AMD vdi sessions.
    # Perhaps due the way I had to build xemacs?
    EExec ec "$@" -e '(progn (raise-frame) (dp-focus-frame))'
fi
