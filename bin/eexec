#!/bin/sh
# $Id: eexec,v 1.16 2005/12/17 08:11:04 davep Exp $
#
# run a program with variable amounts of verbosity and 
# error reporting
#
# usage:
# . eexec
# EExec some-command
# INTTMIG (It Needs This To Make It Go -- Various Paclids.)
# EExec requires command lines like this if you want to EExec both sides of a
# pipe.  Sorry.
# E.g.:
#EExec man -k "$@" \
#    | EExec egrep -e "$regexp"
#
# This way, each EExec doesn't see the rest of the command line and get
# confuzed.
#
# You can set:
# EExecEcho           A command to echo command being executed, def UNSET.
# EExecErrorReporter  A command to report errors, def 'EExecDefErrorReporter'.
# EExecEchoPrefixG    A prefix to print before all output.
# EExecContinue       Non-empty --> continue after errors, def UNSET.
# EExecRCFile         A file in which to accumulate error msgs, def UNSET.
# EExecShowOnly       Don't run commands, just show 'em.
# EExecShowPrefix     What EExecShowOnly prefixes lines with.
# EExecShowCommand    What EExecShowOnly prints lines with.
# You can call:
# EEdie text          Print current value of $?, report text and exit $?.
# EExecDashN          Set EExecShowOnly and EExecShowPrefix.
# EExecVerbose        Set up standard verbosity.
# EExecQuiet          Turn off verbosity.
# EExec_verbose_func  Function to display EExec_verbose_msg messages.

# MUST be set before sourcing or this will NOT work.
# On by default. Call EExecNoExport to disable exportation.
: ${EExecExporter:=export}
${EExecExporter} EExecShowCommand=EExecStderrEcho
${EExecExporter} EExecShowPrefix=""
${EExecExporter} EExecEcho=
${EExecExporter} EExecEchoPrefixG="+"
${EExecExporter} EExec_loaded_p=t
${EExecExporter} EExecShowOnly=
${EExecExporter} EExecErrorReporter=
${EExecExporter} EExec_verbose_func=
${EExecExporter} EExecContinue=

EExec_parse_usage="-n -- Show what would happen but don't do it. [eexec]
-v -- Be verbose about it. [eexec]
-q -- Anti-verbose. [eexec]"

EExec_parse_option_str="nvq"

#
# This is a terrible hack, only working in precise circumstances, but is
# surprisingly useful nonetheless.
# Use it like this:
#e.g. eexec_program=$(EExec_parse "$@")
#e.g. for op in $eexec_program
#e.g. do
#e.g.   $op
#e.g.   shift
#e.g. done

EExec_parse()
{
    local prog=""
    # Can NOT use getopt here because if you use ganged variables then
    # too may args will be shifted.
    # Until I learn how to return a *properly quoted* "$@"
    for i in "$@"
    do
      case "$1" in
          -n) prog="${prog}EExecDashN ";;
          -v) prog="${prog}EExecVerbose ";;
          -q) prog="${prog}EExecQuiet ";;
          --) prog="${prog}EExecNOP";; # Allow user to consume a --
          *) break;;
      esac
      shift
    done
    echo "$prog"
}

# Provide a little helper than removes the need to run the annoying
# eexec_program everywhere. We return the number of ops consumed and the
# caller can just shift that many times.
EExec_parse_n()
{
    local prog=$(EExec_parse "$@")
    local n=0
    for op in $prog
    do
      "$op"
      shift
      ((++n))
    done
    echo $n
}

EExecNOP()
{
    :
}

EExecExport()
{
    export EExecExporter="export"
}

EExecNoExport()
{
    export EExecExporter=""
}

EExecDashN ()
{
    
    if [ "${1-}" == "-k" ]
    then
	${EExecExporter} EExecEcho=EExecStandardErr_eko
        shift
    else
        EExecVerbose
    fi
    ${EExecExporter} EExecShowOnly=y
    ${EExecExporter} EExecShowPrefix="$@"
    ${EExecExporter} EExecEchoPrefixG='-'
}

EExecDashN_p()
{
    [ -n "$EExecShowOnly" ]
}

# Should be named something like EExecSetVerbose (EExec_set_verbose)
EExecVerbose ()
{
    if [ -z "${1-}" ]
    then
	EExec_verbose_func=EExecStderrEcho
    else
	EExec_verbose_func="$1"
    fi
    EExecEcho="$EExec_verbose_func"
}

EExecVerbose_p()
{
    [ n "$EExec_verbose_func" ]
}

EExec_verbose_msg()
{
    local old=${EExecEchoPrefix-}
    EExecEchoPrefix=v
    [ -n "$EExec_verbose_func" ] && "$EExec_verbose_func" "$@"
    EExecEchoPrefix=$old
}

EExecQuiet ()
{
    unset EExecEcho
}


EExecDefErrorReporter ()
{
    rc=$1
    shift
    eMsg="$EExecProgName(EExec): ERROR: `date`, rc: $rc
\`$*' failed ${EExecMsg-}"
    echo "$eMsg" 1>&2
    [ -n "${EExecRCFile-}" ] && echo "$eMsg" >> $EExecRCFile
    ## Just report the news, don't make it. [ -z "${EExecContinue-}" ] && exit $rc
    return $rc
}

EExecStderrEcho()
{
    local ep=${EExecEchoPrefix-$EExecEchoPrefixG}
    #echo ">$EExecEchoPrefix<" 1>&2
    #echo echo "{$EExecEchoPrefix}$*" '1>&2' 1>&2
    echo "{$EExecEchoPrefix}""$@" 1>&2
}

EExecStandardErr_eko()
{
    echo "PATH>$PATH<" 1>&2
    eko "${EExecEchoPrefix}""$@" 1>&2
}

EExecStdoutStderrEcho()
{
    EExecStdout Echo "$*"
    EExecStderrEcho "$*"
}

# die with status passed in
EEdie0()
{
    rc=$1
    shift
    EExecDefErrorReporter $rc $*
    exit $rc
}

# die with status from last command
EEdie()
{
    rc=$?
    EEdie0 $rc "$@"
}

eexecClrDie()
{
    true
}

EExec_start()
{
    echo "$@" | bash -l
}

EExec_start_tcsh()
{
    echo "$@" | tcsh -l
}

EExec()
{
    # @todo XXX Is it worth it to do a full getopt?
    # Only of argv[1] has a leading `-'?
    local i
    local eexecEcho="${EExecEcho}"
    local eexecShowOnly="${EExecShowOnly}"
    local eexecShowPrefix="${EExecShowPrefix}"
    local eexecContinue="${EExecContinue}"
    local eexecErrorReporter="${EExecErrorReporter}"
    local fake_success_p=
    local executor=
    ${EExecExporter} EExecEchoPrefix=$EExecEchoPrefixG
    for i in "$@"
    do
      case "$1" in
          -n) eexecShowOnly=y
              eexecShowPrefix="+"
              eexecEcho=${EExecEcho-EExecStderrEcho}
              ;;
          -c) eexecContinue=t
              ;;
          -C|-0) eexecContinue=t
              fake_success_p=y
              ;;
          -y) eexecShowOnly=""
              eexecShowPrefix=""
              ${EExecExporter} EExecEchoPrefix="y"
              ;;
          -q) eexecErrorReporter=;;
          -x) shift; executor="$1";;
          -tcsh) executor=EExec_start_tcsh
                 ;;
         *) break;;
      esac
      shift
    done

    # $eexecEcho is a command to do our echoing
    [ -n "$eexecEcho" ] && "$eexecEcho" "${eexecShowPrefix}""$@"
    # run the command
    if [ -z "$eexecShowOnly" ]
    then
	$executor "$@" || {
	    rc=$?
            if [ -z "$fake_success_p" ]
            then
                [ -n "$eexecErrorReporter" ] && {
                    "$eexecErrorReporter" $rc "$@"
                }
                [ -z "$eexecContinue" ] && exit $rc
            else
                rc=0
            fi
	    return $rc
	}
    elif [ -z "$eexecEcho" ]
    then
	#echo "$@"
	$EExecShowCommand "${eexecShowPrefix}$@"
    fi
    return 0
}

[ -z "$EExecErrorReporter" ] && {
    ${EExecExporter} EExecErrorReporter=EExecDefErrorReporter
}

#
# preserve historical program name if present,
# otherwise set up a default
#
if vsetp "${prog=}"
then
    ${EExecExporter} EExecProgName="$prog"
elif vsetp "$progname"
then
    ${EExecExporter} EExecProgName="$progname"
elif [ -z "$EExecProgName" ]
then
    ${EExecExporter} EExecProgName="$0"
fi
