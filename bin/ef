#!/bin/sh
# $Id: ef,v 1.20 2005/04/07 08:20:11 davep Exp $
#
# Find a client for emacs, send command, defaulting to edit.
#set -x

source script-x
progname="$(basename $0)"
source eexec

eexec_program=$(EExec_parse "$@")
for op in $eexec_program
do
  $op
  shift
done
unset eexec_program

LOG_FILE="$HOME/log/xemacs/ec-log-file.log"

: ${ask_if_no_display:=t}
: ${ask_about_text_mode:=${ask_if_no_display}}
# The known_* vars are searched in order, so that can be used to specify a
# preference order.
: ${known_servers:=gnuserv}
: ${known_clients:="gnuclient emacsclient"}
: ${known_text_mode_editors:="vim vi nvi nano pico"}
: ${eh=${DP_GNU_EDITING_HOST}}
: ${client=}

editing_host_opt=
editing_host_msg=
quiet_p=

date >| $LOG_FILE
echo >> $LOG_FILE "args>$*<"
for a in "$@"
do
  echo ">$a<" >> $LOG_FILE
  case "$a" in
      -q|--quiet) quiet_p=t; shift;;
  esac
done
echo '--' >> $LOG_FILE

prog=`basename $0`

Usage()
{
   echo "${prog}: usage: $prog [-q]" 1>&2
   exit 1
}

local_server_p()
{
    findprog -s ${known_servers}
}

find_one_of_these_programs()
{
    for p in "$@"
    do
      if sp "$p" > /dev/null
      then
          echo $p
          return 0
      fi
    done
    return 1
}

text_mode_edit()
{
    local textModeEditor="$1"; shift
    local file="$@"

    [ -z "$textModeEditor" ] && {
        echo "Cannot find a text mode editor from $known_text_mode_editors."
        exit 1
    } 1>&2
    if [[ "$do_wait" != 'y' ]]
    then
	echo 1>&2 "Text mode editing doesn't work in the background."
	echo 1>&2 " Running in foreground instead."
    fi
    eval EExec $textModeEditor $file
}

process_file ()
{
    local opts=""
    if [ -n "$1" ]
    then
        if [ -n "$one_file" ]
        then
            file=$*
        else
            file="$1"
	fi
        if [ -n "$2" ]
        then
            opts="$2"
        fi
    else
	file=""
    fi

    local prob=
    local and=
    # Choose a local server over a remote one.
    if ! local_server_p
    then
        if [ -n "$eh" ]
        then
            editing_host_opt="-h $eh"
            [ -z "$quiet_p" ] && {
                editing_host_msg="editing on host: $eh"
            }
        else
            prob="Editing server not found"
            and=" AND "
       fi
    else
        [ -z "$quiet_p" ] && {
            editing_host_msg="editing on localhost: $HOST"
        }
    fi

    if [ -z "$DISPLAY" ]
    then
        prob="${prob}${and}DISPLAY not set"
    fi

    [[ -n "$prob" ]] && {
        if [[ "$ask_about_text_mode" == t ]]; then
            local textModeEditor=$(find-bin ${known_text_mode_editors})
	    echo -n "$progname: "
            read -e -p "$prob; use $textModeEditor instead[Y/n/f/q]? "
            case "$REPLY" in
                Y|y|'')
                   echo 1>&2 "vi'ing"
                   read -e -p "Do this: $textModeEditor $file? "
		   text_mode_edit $textModeEditor $file
                   return 0;;
		# Fake it?  Set up a fake DISPLAY.
                # Surely this is a good enough guess, isn't it?
		[Ff]) export DISPLAY=":0.0"
		      ;;
                [QqXx]) exit 1;;
                *) ;;
            esac
        fi
    }

    #
    # if we're running sawfish, then raise emacs, too.
    # raise first, since sometimes emacs'll prompt for things
    # and gnuclient waits in that case until the prompt is responded to.
    #if [ "$EZEC" != "echo" ] && [ "$have_sawfish" = "0" ]
    #then
    #	sawfish-client -f dp-raise-local-emacs > /dev/null
    #fi

    # send the filename to emacs
    [ "$do_wait" = 'y' ] && nowait_opt=
    [ -n "$editing_host_msg" ] && echo "$editing_host_msg"
    eval EExec $client $editing_host_opt $nowait_opt $eval_opt "$opts" $file
}

# init optional vars to defaults here...

eval_opt=
client=
ECHO="echo $prog: "
CL=

std_options=""
option_str="Qnqe:c:Ews:R12"

q=$(getopt -o "$std_options$option_str" -- "$@")
[ $? != 0 ] && Usage
eval set -- "$q"
unset q
[ $? != 0 ] && Usage

for i in "$@"
do
    case "$1" in
	-e) eval_opt="$eval_opt $2"; shift;;
	# read a string to eval from stdin.
	# getopt WILL NOT preserve spaces! So read funky things from stdin.
	-E) read x; eval_opt="$eval_opt $x";;
	-R) read x; CL="$x";;
	-c) client=$2; shift;;
	-w) do_wait=y;;
        -1) one_file=y;;
        -2) eval_opt="$eval_opt (progn (2w) (other-window 1))";;
        -Q) ask_about_text_mode=t;;
	-s) case "$2" in	# sudo edit the given file
	    /*) file=$2;;
	    *)  file="$PWD/$2";;
	    esac
	    eval_opt="$eval_opt (dp-sudo-edit \"$file\")"; shift;;
	--) shift ; break ;;
	*)
	    echo 1>&2 "Unsupported option>$1<";
	    exit 1 ;;
    esac
    shift
done

args="$*"

if [ -n "$CL" ]
then
    set -- "$CL"
fi

# if there's an eval_opt, wrap it in a progn to make it a single expr
[ -n "$eval_opt" ] && eval_opt="-eval '(progn $eval_opt)'"

#echo "1>$1<"
#echo "eval_opt>$eval_opt<"
if [ -z "$client" ]
then
    client=$(find_one_of_these_programs ${known_clients}) || {
        echo "Cannot find an editing client of $(echo_id known_clients)"
        exit 1
    } 1>&2
    opts=$1
fi

case "$client" in
    emacsclient)
	nowait_opt='--no-wait'
	if [ -n "$eval_opt" ]
	then
	    echo 1>&2 "cannot use eval arg with $client"
	    exit 1
	fi
	;;
    gnuclient)
	nowait_opt='-q'
	;;
    "")
	echo 1>&2 "Cannot find an emacs client in >${known_clients}<"
	exit 1
	;;
esac

findprog -s sawfish
have_sawfish=$?

#echo "args>$args<"
#set -x
if [ -z "$args" ]
then
    process_file
elif [ -n "$one_file" ]
then
    process_file $args # 2>> ec-w.out
else
    set -- $args
    for file in $@
    do
        opts=""
        if [ "${1:0:1}" = "+" ]
        then
            opts="$1"
            shift
        fi
        f="$1"
	process_file "$f" "$opts"
        shift
    done
fi

exit 0
